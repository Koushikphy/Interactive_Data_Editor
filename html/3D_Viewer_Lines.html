<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Interactive Data Editor</title>
    <link href="../lib/style.min.css" rel="stylesheet" />
    <script>
        if (typeof module === 'object') { window.module = module; module = undefined; }
    </script>
    <!-- <script src="../lib/jquery.min.js"></script> -->
</head>

<body>
    <div class="basediv" id="figurecontainer"></div>
    <div class="floatdiv">
    <div id="status"><i><b>Requesting data. Please wait...</b></div>
    <form><input id="is_mark" onclick="mark_clicked(this)" type="checkbox" /> Markers </form>
    <div class="borders">
        Axes Ranges â‡’
        X : <input onchange="setRange(this.value,0)" type="text" id='xInp' />
        Y : <input onchange="setRange(this.value,1)" type="text" id='yInp' />
        Z : <input onchange="setRange(this.value,2)" type="text" id='zInp' />
    </div>
    </div>
    <!-- <script src="../lib/viewer.min.js"></script> -->
    <script>
        require('v8-compile-cache');
        var xxx = [], yyy = [], zzz = [], check = true;
        var figurecontainer = document.getElementById("figurecontainer"),
            data = [],
            swapped = false,
            newCol = [0, 0, 0],
            first = true,
            curCol = false;
        const {ipcRenderer} = require('electron');
        const Plotly = require('plotly.js-gl3d-dist');

        // Plotly.newPlot(figurecontainer, initData(1), layout, { displaylogo: false });

        ipcRenderer.on("sdata", function (e, d) {
            [data, newCol] = d;
            updatePlot();
            if (!curCol) curCol = newCol;
            if (newCol[0] !== curCol[0]) {
                setRange(document.getElementById("xInp").val(),0);
            } else if (newCol[1] !== curCol[1]) {
                setRange(document.getElementById("yInp").val(),1);
            } else if (newCol[2] !== curCol[2]) {
                setRange(document.getElementById("zInp").val(),2);
            }
            curCol = newCol
        })



        function mark_clicked(mark) {
            if (mark.checked) {
                Plotly.restyle(figurecontainer, {
                    'mode': "markers+lines"
                });
            } else {
                Plotly.restyle(figurecontainer, {
                    'mode': "lines"
                });
            };
        };


        function updatePlot() {
            makeRotation();
            xxx = data[0].concat(xxx),
            yyy = data[1].concat(yyy),
            zzz = data[2].concat(zzz);
            if ( first || figurecontainer.data.length != xxx.length) {
                Plotly.newPlot(figurecontainer, initData(xxx.length), layout, { displaylogo: false });
                first = false
            };
            Plotly.restyle(figurecontainer, { 'x': xxx, 'y': yyy, 'z': zzz });
            document.getElementById('status').innerHTML = "<b>Plot Updated on:</b><i> " + new Date().toLocaleString() + "</i>";
        };


        function setRange(lim, axis){
            var tmp = "scene." + ["xaxis.", "yaxis.", "zaxis."][axis]
            console.log(tmp)
            // if(axis==0){
            //     tmp+="xaxis."
            // } else if(axis==1){
            //     tmp+="yaxis."
            // } else{
            //     tmp+="zaxis."
            // }
            if (lim == "") {
                Plotly.relayout(figurecontainer, { [tmp+"autorange"]: true})
            }else {
                lim = lim.split(",").map(x => parseFloat(x))
                if(isNaN(lim[0]) || isNaN(lim[1])){
                    var flat_dat = data[axis].flat();
                    if (isNaN(lim[0])) {
                        lim[0] = Math.min(...flat_dat);
                    }
                    if (isNaN(lim[1])) {
                        lim[1] = Math.max(...flat_dat);
                    }
                }
                Plotly.relayout(figurecontainer, {[tmp+'range'] : lim})
            }
        }


        function transpose(m) {
            return m[0].map((_, i) => m.map(x => x[i]));
        };


        function makeRotation() {
            var issame = true, b = data[0][0].length;
            for (let a of data[0]) {
                if (a.length != b) {
                    issame = false;
                    break;
                };
            };

            if (issame) {
                xxx = transpose(data[0]);
                yyy = transpose(data[1]);
                zzz = transpose(data[2]);
                return;
            };

            var tmpData0 = [].concat(...data[0]).filter(x => x !== undefined),
                tmpData1 = [].concat(...data[1]).filter(x => x !== undefined),
                tmpData2 = [].concat(...data[2]).filter(x => x !== undefined);

            var tmp = [...new Set(tmpData1)].sort((a, b) => a - b);

            xxx = [], yyy = [], zzz = [];
            for (let x of tmp) {
                var tmp0 = [],
                    tmp1 = [],
                    tmp2 = [];
                for (let i = 0; i < tmpData0.length; i++) {
                    if (tmpData1[i] == x) {
                        tmp0.push(tmpData0[i]);
                        tmp1.push(tmpData1[i]);
                        tmp2.push(tmpData2[i]);
                    };
                };
                xxx.push(tmp0);
                yyy.push(tmp1);
                zzz.push(tmp2);
            };
        };


        function initData(length) {
            var pl_data = [];
            for (var i = 0; i < length; i++) {
                pl_data.push({
                    type: 'scatter3d',
                    mode: "lines",
                    x: [1, 2],
                    y: [1, 2],
                    z: [1, 2],
                    marker: {
                        size: 1.7,
                        color: "#1f77b4"
                    },
                    line: {
                        color: '#ff7f0e'
                    },
                    hoverinfo: "x+y+z",
                    hoverlabel: {
                        bgcolor: "#2ca02c"
                    },
                })
            };
            return pl_data
        };


        var layout = {
            height: window.innerHeight + 68,
            width: window.innerWidth - 17,
            margin: {
                t: 0,
                r: 50,
                b: 0,
                l: 25,
                pad: 0
            },
            showlegend: false,
            scene: {
                aspectmode: "cube",
                zaxis: {
                    autorange: true,
                    spikesides: false,
                },
                yaxis: {
                    spikesides: false,
                },
                xaxis: {
                    spikesides: false,
                }
            },
        };
    </script>
</body>

</html>