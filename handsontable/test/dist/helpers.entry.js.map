{"version":3,"file":"helpers.entry.js","sources":["webpack:///webpack/bootstrap 27f3c15f61bbecf36083","webpack:///./test/helpers/index.js","webpack:///external \"window\"","webpack:///./test/bootstrap.js","webpack:///./test/helpers/custom-matchers.js","webpack:///./test/helpers/asciiTable.js","webpack:///./test/helpers/common.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 115);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 27f3c15f61bbecf36083","/* eslint-disable import/no-unresolved */\nimport window from 'window';\nimport './../bootstrap';\nimport * as common from './common';\n\nconst exportToWindow = (helpersHolder) => {\n  Object.keys(helpersHolder).forEach((key) => {\n    if (key === '__esModule') {\n      return;\n    }\n\n    if (window[key] !== void 0) {\n      throw Error(`Cannot export \"${key}\" helper because this name is already assigned.`);\n    }\n\n    window[key] = helpersHolder[key];\n  });\n};\n\n// Export all helpers to the window.\nexportToWindow(common);\n\n\n\n// WEBPACK FOOTER //\n// ./test/helpers/index.js","module.exports = window;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"window\"\n// module id = 116\n// module chunks = 1","import './helpers/custom-matchers';\n\njasmine.DEFAULT_TIMEOUT_INTERVAL = 15000;\n\nbeforeEach(() => {\n  if (document.activeElement && document.activeElement !== document.body) {\n    document.activeElement.blur();\n\n  } else if (!document.activeElement) { // IE\n    document.body.focus();\n  }\n});\n\nafterEach(() => {\n  /* eslint-disable no-unused-expressions */\n  (window.scrollTo || window.scrollTo(0, 0));\n});\n\n\n\n// WEBPACK FOOTER //\n// ./test/bootstrap.js","import { generateASCIITable } from './asciiTable';\n\n// http://stackoverflow.com/questions/986937/how-can-i-get-the-browsers-scrollbar-sizes\nconst scrollbarWidth = (function calculateScrollbarWidth() {\n  const inner = document.createElement('div');\n\n  inner.style.height = '200px';\n  inner.style.width = '100%';\n\n  const outer = document.createElement('div');\n\n  outer.style.boxSizing = 'content-box';\n  outer.style.height = '150px';\n  outer.style.left = '0px';\n  outer.style.overflow = 'hidden';\n  outer.style.position = 'absolute';\n  outer.style.top = '0px';\n  outer.style.width = '200px';\n  outer.style.visibility = 'hidden';\n  outer.appendChild(inner);\n\n  (document.body || document.documentElement).appendChild(outer);\n  const w1 = inner.offsetWidth;\n\n  outer.style.overflow = 'scroll';\n\n  let w2 = inner.offsetWidth;\n\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n\n  (document.body || document.documentElement).removeChild(outer);\n\n  return (w1 - w2);\n}());\n\nbeforeEach(function() {\n  const currentSpec = this;\n\n  function hot() {\n    return currentSpec.$container.data('handsontable');\n  }\n\n  const matchers = {\n    toBeInArray() {\n      return {\n        compare(actual, expected) {\n          return {\n            pass: Array.isArray(expected) && expected.indexOf(actual) > -1\n          };\n        }\n      };\n    },\n    toBeFunction() {\n      return {\n        compare(actual) {\n          return {\n            pass: typeof actual === 'function'\n          };\n        }\n      };\n    },\n    toBeAroundValue() {\n      return {\n        compare(actual, expected, diff) {\n          const margin = diff || 1;\n\n          const pass = actual >= expected - margin && actual <= expected + margin;\n          let message = `Expected ${actual} to be around ${expected} (between ${expected - margin} and ${expected + margin})`;\n\n          if (!pass) {\n            message = `Expected ${actual} NOT to be around ${expected} (between ${expected - margin} and ${expected + margin})`;\n          }\n\n          return {\n            pass,\n            message\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the passed cell element is contained in the table viewport.\n     */\n    toBeVisibleInViewport() {\n      return {\n        compare(actual) {\n          const viewport = hot().view.wt.wtTable.holder;\n          const verticalPosition = actual.offsetTop - viewport.scrollTop + scrollbarWidth + actual.clientHeight;\n          const horizontalPosition = actual.offsetLeft - viewport.scrollLeft + scrollbarWidth + actual.clientWidth;\n\n          const pass = verticalPosition < viewport.offsetHeight && verticalPosition > 0\n            && horizontalPosition < viewport.offsetWidth && horizontalPosition > 0;\n\n          return {\n            pass,\n            message: 'Expected the element to be visible in the Handsontable viewport'\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the viewport is scrolled in the way that the cell is visible at the top of the viewport.\n     */\n    toBeVisibleAtTopOfViewport() {\n      return {\n        compare(actual) {\n          const viewport = hot().view.wt.wtTable.holder;\n          const verticalPosition = actual.offsetTop - viewport.scrollTop - 1;\n\n          return {\n            pass: verticalPosition === 0,\n            message: 'Expected the element to be scrolled to the top of the Handsontable viewport'\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the viewport is scrolled in the way that the cell is visible at the bottom of the viewport.\n     */\n    toBeVisibleAtBottomOfViewport() {\n      return {\n        compare(actual) {\n          const viewport = hot().view.wt.wtTable.holder;\n          const verticalPosition = actual.offsetTop - viewport.scrollTop + scrollbarWidth + actual.clientHeight + 1;\n\n          return {\n            pass: verticalPosition === viewport.offsetHeight,\n            message: 'Expected the element to be scrolled to the bottom of the Handsontable viewport'\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the viewport is scrolled in the way that the cell is visible on the left of the viewport.\n     */\n    toBeVisibleAtLeftOfViewport() {\n      return {\n        compare(actual) {\n          const viewport = hot().view.wt.wtTable.holder;\n          const horizontalPosition = viewport.scrollLeft - actual.offsetLeft;\n\n          return {\n            pass: horizontalPosition === 0,\n            message: 'Expected the element to be scrolled to the top of the Handsontable viewport'\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the viewport is scrolled in the way that the cell is visible on the right of the viewport.\n     */\n    toBeVisibleAtRightOfViewport() {\n      return {\n        compare(actual) {\n          const viewport = hot().view.wt.wtTable.holder;\n          const horizontalPosition = viewport.scrollLeft - actual.offsetLeft + actual.clientWidth - scrollbarWidth + 1;\n\n          return {\n            pass: horizontalPosition === viewport.offsetWidth,\n            message: 'Expected the element to be scrolled to the top of the Handsontable viewport'\n          };\n        }\n      };\n    },\n    toBeListFulfillingCondition() {\n      const redColor = '\\x1b[31m';\n      const resetColor = '\\x1b[0m';\n\n      return {\n        compare(checkedArray, conditionFunction) {\n          if (typeof conditionFunction !== 'function') {\n            throw Error('Parameter passed to `toBeListFulfillingCondition` should be a function.');\n          }\n\n          const isListWithValues = Array.isArray(checkedArray) || checkedArray.length > 0;\n          const elementNotFulfillingCondition = checkedArray.find(element => !conditionFunction(element));\n          const containsUndefined = isListWithValues && checkedArray.includes(undefined);\n          const pass = isListWithValues && !containsUndefined && elementNotFulfillingCondition === undefined;\n          let message;\n\n          if (!isListWithValues) {\n            message = 'Non-empty list should be passed as expect parameter.';\n\n          } else if (containsUndefined) {\n            message = `List ${redColor}${checkedArray.join(', ')}${resetColor} contains ${redColor}undefined${resetColor} value.`;\n\n          } else if (elementNotFulfillingCondition !== undefined) {\n            let entityValue = elementNotFulfillingCondition;\n\n            if (typeof elementNotFulfillingCondition === 'string') {\n              entityValue = `\"${elementNotFulfillingCondition}\"`;\n            }\n\n            message = `Entity ${redColor}${entityValue}${resetColor}, from list: ${redColor}${checkedArray.join(', ')}${resetColor} doesn't satisfy the condition.`;\n          }\n\n          return {\n            pass,\n            message\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the provided selection pattern matches to the rendered cells by checking if\n     * the appropriate CSS class name was added.\n     *\n     * The provided structure should be passed as an array of arrays, for instance:\n     * ```\n     * // Non-contiguous selection (with enabled top and left headers)\n     * expect(`\n     *   |   ║   :   : * : * |\n     *   |===:===:===:===:===|\n     *   | - ║   :   : A : 0 |\n     *   | - ║   : 1 : 0 : 0 |\n     *   | - ║   : 2 : 1 : 0 |\n     *   | - ║   : 2 : 1 : 0 |\n     *   | - ║   : 1 : 1 : 0 |\n     *   | - ║   :   : 0 : 0 |\n     *   `).toBeMatchToSelectionPattern();\n     * // Single cell selection (with fixedRowsTop: 1 and fixedColumnsLeft: 2)\n     * expect(`\n     *   |   :   |   :   :   |\n     *   |---:---:---:---:---|\n     *   |   :   |   :   :   |\n     *   |   :   |   :   :   |\n     *   |   :   | # :   :   |\n     *   |   :   |   :   :   |\n     *   |   :   |   :   :   |\n     *   |   :   |   :   :   |\n     *   `).toBeMatchToSelectionPattern();\n     * ```\n     *\n     * The meaning of the symbol used to describe the cells:\n     * ' ' - An empty space indicates cell which doesn't have added any selection classes.\n     * '0' - The number (from 0 to 7) indicates selected layer level.\n     * 'A' - The letters (from A to H) indicates the position of the cell which contains the hidden editor\n     *       (which `current` class name). The letter `A` indicates the currently selected cell with\n     *       a background of the first layer and `H` as the latest layer (most dark).\n     * '#' - The hash symbol indicates the currently selected cell without changed background color.\n     *\n     * The meaning of the symbol used to describe the table:\n     * ':'   - Column separator (only for better visual looks).\n     * '║'   - This symbol separates the row headers from the table content.\n     * '===' - This symbol separates the column headers from the table content.\n     * '|'   - The symbol which indicates the left overlay edge.\n     * '---' - The symbol which indicates the top overlay edge.\n     */\n    toBeMatchToSelectionPattern() {\n      return {\n        compare(actualPattern) {\n          const asciiTable = generateASCIITable(hot().rootElement);\n\n          const patternParts = (actualPattern || '').split(/\\n/);\n          const redundantPadding = patternParts.reduce((padding, line) => {\n            const trimmedLine = line.trim();\n            let nextPadding = padding;\n\n            if (trimmedLine) {\n              const currentPadding = line.search(/\\S|$/);\n\n              if (currentPadding < nextPadding) {\n                nextPadding = currentPadding;\n              }\n            }\n\n            return nextPadding;\n          }, Infinity);\n\n          const normalizedPattern = patternParts.reduce((acc, line) => {\n            const trimmedLine = line.trim();\n\n            if (trimmedLine) {\n              acc.push(line.substr(redundantPadding));\n            }\n\n            return acc;\n          }, []);\n\n          const actualAsciiTable = normalizedPattern.join('\\n');\n          const message = `Expected the pattern selection \\n${actualAsciiTable}\\nto match to the visual state of the rendered selection \\n${asciiTable}\\n`;\n\n          return {\n            pass: asciiTable === actualAsciiTable,\n            message,\n          };\n        }\n      };\n    },\n  };\n\n  jasmine.addMatchers(matchers);\n});\n\n\n\n// WEBPACK FOOTER //\n// ./test/helpers/custom-matchers.js","/* eslint-disable import/prefer-default-export */\nconst $ = (selector, context = document) => context.querySelector(selector);\n\n/**\n * Return ASCII symbol for headers depends on what the class name HTMLTableCellElement has.\n *\n * @param {HTMLTableCellElement} cell\n * @return {String} Returns '   ', ` * ` or ' - '.\n */\nfunction getSelectionSymbolForHeader(cell) {\n  const hasActiveHeader = cell.classList.contains('ht__active_highlight');\n  const hasHighlight = cell.classList.contains('ht__highlight');\n\n  let symbol = '   ';\n\n  if (hasActiveHeader) {\n    symbol = ' * ';\n\n  } else if (hasHighlight) {\n    symbol = ' - ';\n  }\n\n  return symbol;\n}\n\n/**\n * Return ASCII symbol for cells depends on what the class name HTMLTableCellElement has.\n *\n * @param {HTMLTableCellElement} cell\n * @return {String} Returns valid symbol for the pariticaul cell.\n */\nfunction getSelectionSymbolForCell(cell) {\n  const hasCurrent = cell.classList.contains('current');\n  const hasArea = cell.classList.contains('area');\n  let areaLevel = new Array(7)\n    .fill()\n    .map((_, i, arr) => `area-${arr.length - i}`)\n    .find(className => cell.classList.contains(className));\n\n  areaLevel = areaLevel ? parseInt(areaLevel.replace('area-', ''), 10) : areaLevel;\n\n  let symbol = '   ';\n\n  if (hasCurrent && hasArea && areaLevel) {\n    symbol = ` ${String.fromCharCode(65 + areaLevel)} `;\n\n  } else if (hasCurrent && hasArea && areaLevel === void 0) {\n    symbol = ' A ';\n\n  } else if (hasCurrent && !hasArea && areaLevel === void 0) {\n    symbol = ' # ';\n\n  } else if (!hasCurrent && hasArea && areaLevel === void 0) {\n    symbol = ' 0 ';\n\n  } else if (!hasCurrent && hasArea && areaLevel) {\n    symbol = ` ${areaLevel} `;\n  }\n\n  return symbol;\n}\n\n/**\n * Generate ASCII symbol for passed cell element.\n *\n * @param {HTMLTableCellElement} cell\n * @return {String}\n */\nfunction getSelectionSymbol(cell) {\n  if (isLeftHeader(cell) || isTopHeader(cell)) {\n    return getSelectionSymbolForHeader(cell);\n  }\n\n  return getSelectionSymbolForCell(cell);\n}\n\n/**\n * Check if passed element belong to the left header.\n *\n * @param {HTMLTableCellElement} cell\n * @return {Boolean}\n */\nfunction isLeftHeader(cell) {\n  return cell.tagName === 'TH' && cell.parentElement.parentElement.tagName === 'TBODY';\n}\n\n/**\n * Check if passed element belong to the rop header.\n *\n * @param {HTMLTableCellElement} cell\n * @return {Boolean}\n */\nfunction isTopHeader(cell) {\n  return cell.tagName === 'TH' && cell.parentElement.parentElement.tagName === 'THEAD';\n}\n\n/**\n * @param {HTMLTableElement} overlay\n * @return {Function}\n */\nfunction cellFactory(overlay) {\n  return (row, column) => overlay && overlay.rows[row] && overlay.rows[row].cells[column];\n}\n\n/**\n * Generates table based on Handsontable structure.\n *\n * @param {HTMLElement} context The root element of the Handsontable instance to be generated.\n * @return {String}\n */\nexport function generateASCIITable(context) {\n  const TABLE_EDGES_SYMBOL = '|';\n  const COLUMN_SEPARATOR = ':';\n  const ROW_HEADER_SEPARATOR = '\\u2551';\n  const COLUMN_HEADER_SEPARATOR = '===';\n  const ROW_OVERLAY_SEPARATOR = '|';\n  const COLUMN_OVERLAY_SEPARATOR = '---';\n\n  const cornerOverlayTable = $('.ht_clone_top_left_corner .htCore', context);\n  const leftOverlayTable = $('.ht_clone_left .htCore', context);\n  const topOverlayTable = $('.ht_clone_top .htCore', context);\n  const masterTable = $('.ht_master .htCore', context);\n  const stringRows = [];\n\n  const cornerOverlayCells = cellFactory(cornerOverlayTable);\n  const leftOverlayCells = cellFactory(leftOverlayTable);\n  const topOverlayCells = cellFactory(topOverlayTable);\n  const masterCells = cellFactory(masterTable);\n\n  const hasLeftHeader = leftOverlayCells(1, 0) ? isLeftHeader(leftOverlayCells(1, 0)) : false;\n  const hasTopHeader = topOverlayCells(0, 1) ? isTopHeader(topOverlayCells(0, 1)) : false;\n  const hasCornerHeader = hasLeftHeader && hasTopHeader;\n  const hasFixedLeftCells = leftOverlayCells(1, 1) ? !isLeftHeader(leftOverlayCells(1, 1)) : false;\n  const hasFixedTopCells = topOverlayCells(1, 1) ? !isTopHeader(topOverlayCells(1, 1)) : false;\n\n  const consumedFlags = new Map([\n    ['hasLeftHeader', hasLeftHeader],\n    ['hasTopHeader', hasTopHeader],\n    ['hasCornerHeader', hasCornerHeader],\n    ['hasFixedLeftCells', hasFixedLeftCells],\n    ['hasFixedTopCells', hasLeftHeader],\n  ]);\n\n  const rowsLength = masterTable.rows.length;\n\n  for (let r = 0; r < rowsLength; r++) {\n    const stringCells = [];\n    const columnsLength = masterTable.rows[0].cells.length;\n    let isLastColumn = false;\n    let insertTopOverlayRowSeparator = false;\n\n    for (let c = 0; c < columnsLength; c++) {\n      let cellSymbol;\n      let separatorSymbol = COLUMN_SEPARATOR;\n\n      isLastColumn = c === columnsLength - 1;\n\n      if (cornerOverlayCells(r, c)) {\n        const cell = cornerOverlayCells(r, c);\n        const nextCell = cornerOverlayCells(r, c + 1);\n\n        cellSymbol = getSelectionSymbol(cell);\n\n        if (isLeftHeader(cell) && (!nextCell || !isLeftHeader(nextCell))) {\n          separatorSymbol = ROW_HEADER_SEPARATOR;\n        }\n        if (!isLeftHeader(cell) && !nextCell) {\n          separatorSymbol = ROW_OVERLAY_SEPARATOR;\n        }\n        if (r === 0 && c === 0 && hasCornerHeader) { // Fix for header symbol\n          separatorSymbol = ROW_HEADER_SEPARATOR;\n        }\n\n      } else if (leftOverlayCells(r, c)) {\n        const cell = leftOverlayCells(r, c);\n        const nextCell = leftOverlayCells(r, c + 1);\n\n        cellSymbol = getSelectionSymbol(cell);\n\n        if (isLeftHeader(cell) && (!nextCell || !isLeftHeader(nextCell))) {\n          separatorSymbol = ROW_HEADER_SEPARATOR;\n        }\n        if (!isLeftHeader(cell) && !nextCell) {\n          separatorSymbol = ROW_OVERLAY_SEPARATOR;\n        }\n\n      } else if (topOverlayCells(r, c)) {\n        const cell = topOverlayCells(r, c);\n\n        cellSymbol = getSelectionSymbol(cell);\n\n        if (hasFixedTopCells && isLastColumn && !topOverlayCells(r + 1, c)) {\n          insertTopOverlayRowSeparator = true;\n        }\n\n      } else if (masterCells(r, c)) {\n        const cell = masterCells(r, c);\n\n        cellSymbol = getSelectionSymbol(cell);\n      }\n\n      stringCells.push(cellSymbol);\n\n      if (!isLastColumn) {\n        stringCells.push(separatorSymbol);\n      }\n    }\n\n    stringRows.push(TABLE_EDGES_SYMBOL + stringCells.join('') + TABLE_EDGES_SYMBOL);\n\n    if (consumedFlags.get('hasTopHeader')) {\n      consumedFlags.delete('hasTopHeader');\n      stringRows.push(TABLE_EDGES_SYMBOL + new Array(columnsLength).fill(COLUMN_HEADER_SEPARATOR).join(COLUMN_SEPARATOR) + TABLE_EDGES_SYMBOL);\n    }\n    if (insertTopOverlayRowSeparator) {\n      insertTopOverlayRowSeparator = false;\n      stringRows.push(TABLE_EDGES_SYMBOL + new Array(columnsLength).fill(COLUMN_OVERLAY_SEPARATOR).join(COLUMN_SEPARATOR) + TABLE_EDGES_SYMBOL);\n    }\n  }\n\n  return stringRows.join('\\n');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./test/helpers/asciiTable.js","export function sleep(delay = 100) {\n  return Promise.resolve({\n    then(resolve) {\n      setTimeout(resolve, delay);\n    }\n  });\n}\n\nexport function promisfy(fn) {\n  return new Promise((resolve, reject) => fn(resolve, reject));\n}\n\n/**\n * Calls a method in current Handsontable instance, returns its output\n * @param method\n * @return {Function}\n */\nexport function handsontableMethodFactory(method) {\n  return function(...args) {\n    let instance;\n\n    try {\n      instance = spec().$container.handsontable('getInstance');\n    } catch (err) {\n      /* eslint-disable */\n      console.error(err);\n      /* eslint-enable */\n    }\n\n    if (instance) {\n      if (method === 'destroy') {\n        spec().$container.removeData();\n      }\n    } else {\n      if (method === 'destroy') {\n        return; // we can forgive this... maybe it was destroyed in the test\n      }\n      throw new Error('Something wrong with the test spec: Handsontable instance not found');\n    }\n\n    return instance[method](...args);\n  };\n}\n\nexport const addHook = handsontableMethodFactory('addHook');\nexport const alter = handsontableMethodFactory('alter');\nexport const colToProp = handsontableMethodFactory('colToProp');\nexport const countCols = handsontableMethodFactory('countCols');\nexport const countEmptyCols = handsontableMethodFactory('countEmptyCols');\nexport const countEmptyRows = handsontableMethodFactory('countEmptyRows');\nexport const countRows = handsontableMethodFactory('countRows');\nexport const countSourceCols = handsontableMethodFactory('countSourceCols');\nexport const countSourceRows = handsontableMethodFactory('countSourceRows');\nexport const deselectCell = handsontableMethodFactory('deselectCell');\nexport const destroy = handsontableMethodFactory('destroy');\nexport const destroyEditor = handsontableMethodFactory('destroyEditor');\nexport const emptySelectedCells = handsontableMethodFactory('emptySelectedCells');\nexport const getActiveEditor = handsontableMethodFactory('getActiveEditor');\nexport const getCell = handsontableMethodFactory('getCell');\nexport const getCellEditor = handsontableMethodFactory('getCellEditor');\nexport const getCellMeta = handsontableMethodFactory('getCellMeta');\nexport const getCellMetaAtRow = handsontableMethodFactory('getCellMetaAtRow');\nexport const getCellRenderer = handsontableMethodFactory('getCellRenderer');\nexport const getCellsMeta = handsontableMethodFactory('getCellsMeta');\nexport const getCellValidator = handsontableMethodFactory('getCellValidator');\nexport const getColHeader = handsontableMethodFactory('getColHeader');\nexport const getCopyableData = handsontableMethodFactory('getCopyableData');\nexport const getCopyableText = handsontableMethodFactory('getCopyableText');\nexport const getData = handsontableMethodFactory('getData');\nexport const getDataAtCell = handsontableMethodFactory('getDataAtCell');\nexport const getDataAtCol = handsontableMethodFactory('getDataAtCol');\nexport const getDataAtRow = handsontableMethodFactory('getDataAtRow');\nexport const getDataAtRowProp = handsontableMethodFactory('getDataAtRowProp');\nexport const getDataType = handsontableMethodFactory('getDataType');\nexport const getInstance = handsontableMethodFactory('getInstance');\nexport const getPlugin = handsontableMethodFactory('getPlugin');\nexport const getRowHeader = handsontableMethodFactory('getRowHeader');\nexport const getSelected = handsontableMethodFactory('getSelected');\nexport const getSelectedLast = handsontableMethodFactory('getSelectedLast');\nexport const getSelectedRange = handsontableMethodFactory('getSelectedRange');\nexport const getSelectedRangeLast = handsontableMethodFactory('getSelectedRangeLast');\nexport const getSourceData = handsontableMethodFactory('getSourceData');\nexport const getSourceDataArray = handsontableMethodFactory('getSourceDataArray');\nexport const getSourceDataAtCell = handsontableMethodFactory('getSourceDataAtCell');\nexport const getSourceDataAtCol = handsontableMethodFactory('getSourceDataAtCol');\nexport const getSourceDataAtRow = handsontableMethodFactory('getSourceDataAtRow');\nexport const getValue = handsontableMethodFactory('getValue');\nexport const loadData = handsontableMethodFactory('loadData');\nexport const populateFromArray = handsontableMethodFactory('populateFromArray');\nexport const propToCol = handsontableMethodFactory('propToCol');\nexport const removeCellMeta = handsontableMethodFactory('removeCellMeta');\nexport const render = handsontableMethodFactory('render');\nexport const selectAll = handsontableMethodFactory('selectAll');\nexport const selectCell = handsontableMethodFactory('selectCell');\nexport const selectCells = handsontableMethodFactory('selectCells');\nexport const selectColumns = handsontableMethodFactory('selectColumns');\nexport const selectRows = handsontableMethodFactory('selectRows');\nexport const setCellMeta = handsontableMethodFactory('setCellMeta');\nexport const setDataAtCell = handsontableMethodFactory('setDataAtCell');\nexport const setDataAtRowProp = handsontableMethodFactory('setDataAtRowProp');\nexport const spliceCellsMeta = handsontableMethodFactory('spliceCellsMeta');\nexport const spliceCol = handsontableMethodFactory('spliceCol');\nexport const spliceRow = handsontableMethodFactory('spliceRow');\nexport const updateSettings = handsontableMethodFactory('updateSettings');\nexport const undo = handsontableMethodFactory('undo');\n\nconst specContext = {};\n\nbeforeEach(function() {\n  specContext.spec = this;\n});\nafterEach(() => {\n  specContext.spec = null;\n});\n\nexport function spec() {\n  return specContext.spec;\n}\n\nexport function hot() {\n  return spec().$container.data('handsontable');\n}\n\nexport function handsontable(options) {\n  const currentSpec = spec();\n\n  currentSpec.$container.handsontable(options);\n  currentSpec.$container[0].focus(); // otherwise TextEditor tests do not pass in IE8\n\n  return currentSpec.$container.data('handsontable');\n}\n\n/**\n * As for v. 0.11 the only scrolling method is native scroll, which creates copies of main htCore table inside of the container.\n * Therefore, simple $(\".htCore\") will return more than one object. Most of the time, you're interested in the original\n * htCore, not the copies made by native scroll.\n *\n * This method returns the original htCore object\n *\n * @returns {jqObject} reference to the original htCore\n */\nexport function getHtCore() {\n  return spec().$container.find('.htCore').first();\n}\n\nexport function getMaster() {\n  return spec().$container.find('.ht_master');\n}\n\nexport function getTopClone() {\n  return spec().$container.find('.ht_clone_top');\n}\n\nexport function getTopLeftClone() {\n  return spec().$container.find('.ht_clone_top_left_corner');\n}\n// for compatybility\n// const getCornerClone = getTopLeftClone;\n\nexport function getLeftClone() {\n  return spec().$container.find('.ht_clone_left');\n}\n\nexport function getBottomClone() {\n  return spec().$container.find('.ht_clone_bottom');\n}\n\nexport function getBottomLeftClone() {\n  return spec().$container.find('.ht_clone_bottom_left_corner');\n}\n\n// Rename me to countTD\nexport function countCells() {\n  return getHtCore().find('tbody td').length;\n}\n\nexport function isEditorVisible(editableElement) {\n  if (editableElement && !(editableElement.hasClass('handsontableInput') || editableElement.hasClass('handsontableEditor'))) {\n    throw new Error('Editable element of the editor was not found.');\n  }\n\n  const keyProxyHolder = (editableElement || keyProxy()).parent();\n\n  if (keyProxyHolder.size() === 0) {\n    return false;\n  }\n  const css = cssProp => keyProxyHolder.css(cssProp);\n\n  return css('z-index') !== '-1' && css('top') !== '-9999px' && css('left') !== '-9999px';\n}\n\nexport function isFillHandleVisible() {\n  return !!spec().$container.find('.wtBorder.corner:visible').length;\n}\n\nexport function getCorrespondingOverlay(cell, container) {\n  const overlay = $(cell).parents('.handsontable');\n\n  if (overlay[0] === container[0]) {\n    return $('.ht_master');\n  }\n\n  return $(overlay[0]);\n}\n\n/**\n * Shows context menu\n */\nexport function contextMenu(cell) {\n  const hotInstance = spec().$container.data('handsontable');\n  let clickedCell = cell;\n  let selected = hotInstance.getSelectedLast();\n\n  if (!selected) {\n    hotInstance.selectCell(0, 0);\n    selected = hotInstance.getSelectedLast();\n  }\n  if (!clickedCell) {\n    clickedCell = getCell(selected[0], selected[1]);\n  }\n  const cellOffset = $(clickedCell).offset();\n\n  $(clickedCell).simulate('mousedown', { button: 2 });\n  $(clickedCell).simulate('contextmenu', {\n    clientX: cellOffset.left - Handsontable.dom.getWindowScrollLeft(),\n    clientY: cellOffset.top - Handsontable.dom.getWindowScrollTop(),\n  });\n  // Chrome doesn't call `mouseup`.\n  // $(cell).simulate('mouseup', { button: 2 });\n}\n\nexport function closeContextMenu() {\n  $(document).simulate('mousedown');\n  // $(document).trigger('mousedown');\n}\n\n/**\n * Shows dropdown menu\n */\nexport function dropdownMenu(columnIndex) {\n  const hotInstance = spec().$container.data('handsontable');\n  const th = hotInstance.view.wt.wtTable.getColumnHeader(columnIndex || 0);\n  const button = th.querySelector('.changeType');\n\n  if (button) {\n    $(button).simulate('mousedown');\n    $(button).simulate('click');\n  }\n}\n\nexport function closeDropdownMenu() {\n  $(document).simulate('mousedown');\n}\n\nexport function dropdownMenuRootElement() {\n  const plugin = hot().getPlugin('dropdownMenu');\n  let root;\n\n  if (plugin && plugin.menu) {\n    root = plugin.menu.container;\n  }\n\n  return root;\n}\n\n/**\n * Returns a function that triggers a mouse event\n * @param {String} type Event type\n * @return {Function}\n */\nexport function handsontableMouseTriggerFactory(type, button) {\n  return function(element) {\n    let handsontableElement = element;\n\n    if (!(handsontableElement instanceof jQuery)) {\n      handsontableElement = $(handsontableElement);\n    }\n    const ev = $.Event(type);\n    ev.which = button || 1; // left click by default\n\n    handsontableElement.simulate(type, ev);\n  };\n}\n\nexport const mouseDown = handsontableMouseTriggerFactory('mousedown');\nexport const mouseMove = handsontableMouseTriggerFactory('mousemove');\nexport const mouseOver = handsontableMouseTriggerFactory('mouseover');\nexport const mouseUp = handsontableMouseTriggerFactory('mouseup');\n\nexport function mouseDoubleClick(element) {\n  mouseDown(element);\n  mouseUp(element);\n  mouseDown(element);\n  mouseUp(element);\n}\n\nexport const mouseRightDown = handsontableMouseTriggerFactory('mousedown', 3);\nexport const mouseRightUp = handsontableMouseTriggerFactory('mouseup', 3);\n\n/**\n * Returns a function that triggers a key event\n * @param {String} type Event type\n * @return {Function}\n */\nexport function handsontableKeyTriggerFactory(type) {\n  return function(key, extend) {\n    const ev = {}; // $.Event(type);\n    let keyToTrigger = key;\n\n    if (typeof keyToTrigger === 'string') {\n      if (keyToTrigger.indexOf('shift+') > -1) {\n        keyToTrigger = keyToTrigger.substring(6);\n        ev.shiftKey = true;\n      }\n\n      if (keyToTrigger.indexOf('ctrl+') > -1) {\n        keyToTrigger = keyToTrigger.substring(5);\n        ev.ctrlKey = true;\n        ev.metaKey = true;\n      }\n\n      switch (keyToTrigger) {\n        case 'tab':\n          ev.keyCode = 9;\n          break;\n\n        case 'enter':\n          ev.keyCode = 13;\n          break;\n\n        case 'esc':\n          ev.keyCode = 27;\n          break;\n\n        case 'f2':\n          ev.keyCode = 113;\n          break;\n\n        case 'arrow_left':\n          ev.keyCode = 37;\n          break;\n\n        case 'arrow_up':\n          ev.keyCode = 38;\n          break;\n\n        case 'arrow_right':\n          ev.keyCode = 39;\n          break;\n\n        case 'arrow_down':\n          ev.keyCode = 40;\n          break;\n\n        case 'ctrl':\n          if (window.navigator.platform.includes('Mac')) {\n            ev.keyCode = 91;\n          } else {\n            ev.keyCode = 17;\n          }\n          break;\n\n        case 'shift':\n          ev.keyCode = 16;\n          break;\n\n        case 'backspace':\n          ev.keyCode = 8;\n          break;\n\n        case 'delete':\n          ev.keyCode = 46;\n          break;\n\n        case 'space':\n          ev.keyCode = 32;\n          break;\n\n        case 'x':\n          ev.keyCode = 88;\n          break;\n\n        case 'c':\n          ev.keyCode = 67;\n          break;\n\n        case 'v':\n          ev.keyCode = 86;\n          break;\n\n        case 'a':\n          ev.keyCode = 65;\n          break;\n\n        default:\n          throw new Error(`Unrecognised key name: ${keyToTrigger}`);\n      }\n\n    } else if (typeof keyToTrigger === 'number') {\n      ev.keyCode = keyToTrigger;\n    }\n    //    ev.originalEvent = {}; //needed as long Handsontable searches for event.originalEvent\n    $.extend(ev, extend);\n    $(document.activeElement).simulate(type, ev);\n  };\n}\n\nexport const keyDown = handsontableKeyTriggerFactory('keydown');\nexport const keyUp = handsontableKeyTriggerFactory('keyup');\n\n/**\n * Presses keyDown, then keyUp\n */\nexport function keyDownUp(key, extend) {\n  if (typeof key === 'string' && key.indexOf('shift+') > -1) {\n    keyDown('shift');\n  }\n\n  keyDown(key, extend);\n  keyUp(key, extend);\n\n  if (typeof key === 'string' && key.indexOf('shift+') > -1) {\n    keyUp('shift');\n  }\n}\n\n/**\n * Returns current value of the keyboard proxy textarea\n * @return {String}\n */\nexport function keyProxy() {\n  return spec().$container.find('textarea.handsontableInput');\n}\n\nexport function serveImmediatePropagation(event) {\n  if ((event !== null || event !== void 0)\n    && (event.isImmediatePropagationEnabled === null || event.isImmediatePropagationEnabled === void 0)) {\n    event.stopImmediatePropagation = function() {\n      this.isImmediatePropagationEnabled = false;\n      this.cancelBubble = true;\n    };\n    event.isImmediatePropagationEnabled = true;\n    event.isImmediatePropagationStopped = function() {\n      return !this.isImmediatePropagationEnabled;\n    };\n  }\n\n  return event;\n}\n\nexport function autocompleteEditor() {\n  return spec().$container.find('.handsontableInput');\n}\n\n/**\n * Sets text cursor inside keyboard proxy\n */\nexport function setCaretPosition(pos) {\n  const el = keyProxy()[0];\n\n  if (el.setSelectionRange) {\n    el.focus();\n    el.setSelectionRange(pos, pos);\n\n  } else if (el.createTextRange) {\n    const range = el.createTextRange();\n    range.collapse(true);\n    range.moveEnd('character', pos);\n    range.moveStart('character', pos);\n    range.select();\n  }\n}\n\n/**\n * Returns autocomplete instance\n */\nexport function autocomplete() {\n  return spec().$container.find('.autocompleteEditor');\n}\n\n/**\n * Triggers paste string on current selection\n */\nexport function triggerPaste(str) {\n  spec().$container.data('handsontable').getPlugin('CopyPaste').paste(str);\n}\n\n/**\n * Returns column width for HOT container\n * @param $elem\n * @param col\n * @returns {Number}\n */\nexport function colWidth($elem, col) {\n  const TR = $elem[0].querySelector('TBODY TR');\n  let cell;\n\n  if (TR) {\n    cell = TR.querySelectorAll('TD')[col];\n  } else {\n    cell = $elem[0].querySelector('THEAD TR').querySelectorAll('TH')[col];\n  }\n\n  if (!cell) {\n    throw new Error(`Cannot find table column of index '${col}'`);\n  }\n\n  return cell.offsetWidth;\n}\n\n/**\n * Returns row height for HOT container\n * @param $elem\n * @param row\n * @returns {Number}\n */\nexport function rowHeight($elem, row) {\n  let TD;\n\n  if (row >= 0) {\n    TD = $elem[0].querySelector(`tbody tr:nth-child(${row + 1}) td`);\n  } else {\n    TD = $elem[0].querySelector(`thead tr:nth-child(${Math.abs(row)})`);\n  }\n\n  if (!TD) {\n    throw new Error(`Cannot find table row of index '${row}'`);\n  }\n\n  return Handsontable.dom.outerHeight(TD);\n}\n\n/**\n * Returns value that has been rendered in table cell\n * @param {Number} trIndex\n * @param {Number} tdIndex\n * @returns {String}\n */\nexport function getRenderedValue(trIndex, tdIndex) {\n  return spec().$container.find('tbody tr').eq(trIndex).find('td').eq(tdIndex).html();\n}\n\n/**\n * Returns nodes that have been rendered in table cell\n * @param {Number} trIndex\n * @param {Number} tdIndex\n * @returns {String}\n */\nexport function getRenderedContent(trIndex, tdIndex) {\n  return spec().$container.find('tbody tr').eq(trIndex).find('td').eq(tdIndex).children();\n}\n\n/**\n * Create numerical data values for the table\n * @param rowCount\n * @param colCount\n * @returns {Array}\n */\nexport function createNumericData(rowCount, colCount) {\n  const rowsMax = typeof rowCount === 'number' ? rowCount : 100;\n  const columnsMax = typeof colCount === 'number' ? colCount : 4;\n  const rows = [];\n  let i;\n  let j;\n\n  for (i = 0; i < rowsMax; i++) {\n    const row = [];\n\n    for (j = 0; j < columnsMax; j++) {\n      row.push((i + 1));\n    }\n    rows.push(row);\n  }\n\n  return rows;\n}\n\n/**\n * Model factory, which creates object with private properties, accessible by setters and getters.\n * Created for the purpose of testing HOT with Backbone-like Models\n * @param opts\n * @returns {{}}\n * @constructor\n */\nexport function Model(opts) {\n  const obj = {};\n\n  const _data = $.extend({\n    id: undefined,\n    name: undefined,\n    address: undefined\n  }, opts);\n\n  obj.attr = function(name, value) {\n    if (typeof value === 'undefined') {\n      return this.get(name);\n    }\n\n    return this.set(name, value);\n  };\n\n  obj.get = function(name) {\n    return _data[name];\n  };\n\n  obj.set = function(name, value) {\n    _data[name] = value;\n\n    return this;\n  };\n\n  return obj;\n}\n/**\n * Factory which produces an accessor for objects of type \"Model\" (see above).\n * This function should be used to create accessor for a given property name and pass it as `data` option in column\n * configuration.\n *\n * @param name - name of the property for which an accessor function will be created\n * @returns {Function}\n */\nexport function createAccessorForProperty(name) {\n  return function(obj, value) {\n    return obj.attr(name, value);\n  };\n}\n\nexport function resizeColumn(displayedColumnIndex, width) {\n  const $container = spec().$container;\n  const $th = $container.find(`thead tr:eq(0) th:eq(${displayedColumnIndex})`);\n\n  $th.simulate('mouseover');\n\n  const $resizer = $container.find('.manualColumnResizer');\n  const resizerPosition = $resizer.position();\n\n  $resizer.simulate('mousedown', {\n    clientX: resizerPosition.left,\n  });\n\n  const delta = width - $th.width() - 2;\n  const newPosition = resizerPosition.left + delta;\n  $resizer.simulate('mousemove', {\n    clientX: newPosition\n  });\n\n  $resizer.simulate('mouseup');\n}\n\nexport function resizeRow(displayedRowIndex, height) {\n  const $container = spec().$container;\n  const $th = $container.find(`tbody tr:eq(${displayedRowIndex}) th:eq(0)`);\n\n  $th.simulate('mouseover');\n\n  const $resizer = $container.find('.manualRowResizer');\n  const resizerPosition = $resizer.position();\n\n  $resizer.simulate('mousedown', {\n    clientY: resizerPosition.top\n  });\n\n  let delta = height - $th.height() - 2;\n\n  if (delta < 0) {\n    delta = 0;\n  }\n\n  $resizer.simulate('mousemove', {\n    clientY: resizerPosition.top + delta\n  });\n\n  $resizer.simulate('mouseup');\n}\n\nexport function moveSecondDisplayedRowBeforeFirstRow(container, secondDisplayedRowIndex) {\n  const $mainContainer = container.parents('.handsontable').not('[class*=clone]').not('[class*=master]').first();\n  const $rowHeaders = container.find('tbody tr th');\n  const $firstRowHeader = $rowHeaders.eq(secondDisplayedRowIndex - 1);\n  const $secondRowHeader = $rowHeaders.eq(secondDisplayedRowIndex);\n\n  $secondRowHeader.simulate('mouseover');\n  const $manualRowMover = $mainContainer.find('.manualRowMover');\n\n  if ($manualRowMover.length) {\n    $manualRowMover.simulate('mousedown', {\n      clientY: $manualRowMover[0].getBoundingClientRect().top\n    });\n\n    $manualRowMover.simulate('mousemove', {\n      clientY: $manualRowMover[0].getBoundingClientRect().top - 20\n    });\n\n    $firstRowHeader.simulate('mouseover');\n    $secondRowHeader.simulate('mouseup');\n  }\n}\n\nexport function moveFirstDisplayedRowAfterSecondRow(container, firstDisplayedRowIndex) {\n  const $mainContainer = container.parents('.handsontable').not('[class*=clone]').not('[class*=master]').first();\n  const $rowHeaders = container.find('tbody tr th');\n  const $firstRowHeader = $rowHeaders.eq(firstDisplayedRowIndex);\n  const $secondRowHeader = $rowHeaders.eq(firstDisplayedRowIndex + 1);\n\n  $secondRowHeader.simulate('mouseover');\n  const $manualRowMover = $mainContainer.find('.manualRowMover');\n\n  if ($manualRowMover.length) {\n    $manualRowMover.simulate('mousedown', {\n      clientY: $manualRowMover[0].getBoundingClientRect().top\n    });\n\n    $manualRowMover.simulate('mousemove', {\n      clientY: $manualRowMover[0].getBoundingClientRect().top + 20\n    });\n\n    $firstRowHeader.simulate('mouseover');\n    $secondRowHeader.simulate('mouseup');\n  }\n}\n\nexport function swapDisplayedColumns(container, from, to) {\n  const $mainContainer = container.parents('.handsontable').not('[class*=clone]').not('[class*=master]').first();\n  const $colHeaders = container.find('thead tr:eq(0) th');\n  const $to = $colHeaders.eq(to);\n  const $from = $colHeaders.eq(from);\n\n  // Enter the second column header\n  $from.simulate('mouseover');\n  const $manualColumnMover = $mainContainer.find('.manualColumnMover');\n\n  // Grab the second column\n  $manualColumnMover.simulate('mousedown', {\n    pageX: $manualColumnMover[0].getBoundingClientRect().left,\n  });\n\n  // Drag the second column over the first column\n  $manualColumnMover.simulate('mousemove', {\n    pageX: $manualColumnMover[0].getBoundingClientRect().left - 20,\n  });\n\n  $to.simulate('mouseover');\n\n  // Drop the second column\n  $from.simulate('mouseup');\n}\n\nexport function triggerTouchEvent(type, target, pageX, pageY) {\n  const e = document.createEvent('TouchEvent');\n\n  const targetCoords = target.getBoundingClientRect();\n  const targetPageX = pageX || parseInt(targetCoords.left + 3, 10);\n  const targetPageY = pageY || parseInt(targetCoords.top + 3, 10);\n  let touches;\n  let targetTouches;\n  let changedTouches;\n\n  const touch = document.createTouch(window, target, 0, targetPageX, targetPageY, targetPageX, targetPageY);\n\n  if (type === 'touchend') {\n    touches = document.createTouchList();\n    targetTouches = document.createTouchList();\n    changedTouches = document.createTouchList(touch);\n  } else {\n    touches = document.createTouchList(touch);\n    targetTouches = document.createTouchList(touch);\n    changedTouches = document.createTouchList(touch);\n  }\n\n  e.initTouchEvent(type, true, true, window, null, 0, 0, 0, 0, false, false, false, false, touches, targetTouches, changedTouches, 1, 0);\n  target.dispatchEvent(e);\n}\n\nexport function createSpreadsheetData(...args) {\n  return Handsontable.helper.createSpreadsheetData(...args);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./test/helpers/common.js"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5DA;AACA;AAAA;AACA;AAAA;AACA;;;;;AAJA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpBA;;;;;;;;;;ACAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AALA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAfA;AAiBA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAFA;AAIA;AAbA;AAeA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AATA;AAWA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AATA;AAWA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AATA;AAWA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AATA;AAWA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAhCA;AAkCA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AArCA;AAuCA;AAtPA;AAyPA;AACA;;;;;;;;;;;;;ACtSA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;;;;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AAEA;;;;;;AAIA;AACA;AAAA;AAAA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7NA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;;;;;;;AAKA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;;;;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1EA;AA6EA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AAEA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AADA;AAIA;AACA;AACA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AADA;AACA;AAIA;AACA;AADA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;A","sourceRoot":""}