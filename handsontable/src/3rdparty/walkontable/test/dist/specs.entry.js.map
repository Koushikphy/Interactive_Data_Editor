{"version":3,"file":"specs.entry.js","sources":["webpack:///webpack/bootstrap f341a63acd3d4e1e0e3c","webpack:///./src/3rdparty/walkontable/test/spec/index.js","webpack:///./src/3rdparty/walkontable/test/spec \\.spec\\.js$","webpack:///./src/3rdparty/walkontable/test/spec/border.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/calculator/viewportColumns.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/calculator/viewportRows.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/cell/coords.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/cell/range.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/core.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/event.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/filter/column.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/filter/row.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/scroll.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/scrollbar.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/scrollbarNative.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/selection.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/settings/columnHeaders.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/settings/preventOverflow.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/settings/rowHeaders.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/settings/stretchH.spec.js","webpack:///./src/3rdparty/walkontable/test/spec/table.spec.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f341a63acd3d4e1e0e3c","[\n  require.context('.', true, /\\.spec\\.js$/),\n].forEach((req) => {\n  req.keys().forEach((key) => {\n    req(key);\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/index.js","var map = {\n\t\"./border.spec.js\": 9,\n\t\"./calculator/viewportColumns.spec.js\": 10,\n\t\"./calculator/viewportRows.spec.js\": 11,\n\t\"./cell/coords.spec.js\": 12,\n\t\"./cell/range.spec.js\": 13,\n\t\"./core.spec.js\": 14,\n\t\"./event.spec.js\": 15,\n\t\"./filter/column.spec.js\": 16,\n\t\"./filter/row.spec.js\": 17,\n\t\"./scroll.spec.js\": 18,\n\t\"./scrollbar.spec.js\": 19,\n\t\"./scrollbarNative.spec.js\": 20,\n\t\"./selection.spec.js\": 21,\n\t\"./settings/columnHeaders.spec.js\": 22,\n\t\"./settings/preventOverflow.spec.js\": 23,\n\t\"./settings/rowHeaders.spec.js\": 24,\n\t\"./settings/stretchH.spec.js\": 25,\n\t\"./table.spec.js\": 26\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 8;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/3rdparty/walkontable/test/spec \\.spec\\.js$\n// module id = 8\n// module chunks = 0","describe('WalkontableBorder', () => {\n  let $table;\n  let $container;\n  let $wrapper;\n  const debug = false;\n\n  beforeEach(() => {\n    $container = $('<div></div>');\n    $wrapper = $('<div></div>');\n    $container.width(100).height(200);\n    $table = $('<table></table>');\n    $container.append($wrapper);\n    $wrapper.append($table);\n    $container.appendTo('body');\n    createDataArray();\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n    $container.remove();\n  });\n\n  it('should add/remove border to selection when cell is clicked', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: 5,\n      totalColumns: 5,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          border: {\n            width: 1,\n            color: 'red'\n          }\n        })\n      }),\n      onCellMouseDown(event, coords) {\n        wt.selections.getCell().clear();\n        wt.selections.getCell().add(coords);\n        wt.draw();\n      }\n    });\n    wt.draw();\n\n    const $td1 = $table.find('tbody tr:eq(1) td:eq(0)');\n\n    const $td2 = $table.find('tbody tr:eq(2) td:eq(1)');\n    const $top = $(wt.selections.getCell().getBorder(wt).top);\n    const $right = $(wt.selections.getCell().getBorder(wt).right);\n    const $bottom = $(wt.selections.getCell().getBorder(wt).bottom);\n    const $left = $(wt.selections.getCell().getBorder(wt).left);\n\n    $td1.simulate('mousedown');\n\n    expect($top.css('height')).toBe('1px');\n    expect($top.position().top).toBe(23);\n    expect($top.position().left).toBe(0);\n    expect($right.css('width')).toBe('1px');\n    expect($right.position().top).toBe(23);\n    expect($right.position().left).toBe(49);\n    expect($bottom.css('height')).toBe('1px');\n    expect($bottom.position().top).toBe(46);\n    expect($bottom.position().left).toBe(0);\n    expect($left.css('width')).toBe('1px');\n    expect($left.position().top).toBe(23);\n    expect($left.position().left).toBe(0);\n\n    $td2.simulate('mousedown');\n\n    expect($top.css('height')).toBe('1px');\n    expect($top.position().top).toBe(46);\n    expect($top.position().left).toBe(49);\n    expect($right.css('width')).toBe('1px');\n    expect($right.position().top).toBe(46);\n    expect($right.position().left).toBe(99);\n    expect($bottom.css('height')).toBe('1px');\n    expect($bottom.position().top).toBe(69);\n    expect($bottom.position().left).toBe(49);\n    expect($left.css('width')).toBe('1px');\n    expect($left.position().top).toBe(46);\n    expect($left.position().left).toBe(49);\n  });\n\n  it('should add/remove border to selection when cell is clicked and the table has only one column', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: 5,\n      totalColumns: 1,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          border: {\n            width: 1,\n            color: 'red'\n          }\n        })\n      }),\n      onCellMouseDown(event, coords) {\n        wt.selections.getCell().clear();\n        wt.selections.getCell().add(coords);\n        wt.draw();\n      }\n    });\n    wt.draw();\n\n    const $td1 = $table.find('tbody tr:eq(1) td:eq(0)');\n    const $top = $(wt.selections.getCell().getBorder(wt).top);\n    const $right = $(wt.selections.getCell().getBorder(wt).right);\n    const $bottom = $(wt.selections.getCell().getBorder(wt).bottom);\n    const $left = $(wt.selections.getCell().getBorder(wt).left);\n\n    $td1.simulate('mousedown');\n\n    expect($top.css('height')).toBe('1px');\n    expect($top.position().top).toBe(23);\n    expect($top.position().left).toBe(0);\n    expect($right.css('width')).toBe('1px');\n    expect($right.position().top).toBe(23);\n    expect($right.position().left).toBe(49);\n    expect($bottom.css('height')).toBe('1px');\n    expect($bottom.position().top).toBe(46);\n    expect($bottom.position().left).toBe(0);\n    expect($left.css('width')).toBe('1px');\n    expect($left.position().top).toBe(23);\n    expect($left.position().left).toBe(0);\n  });\n\n  it('should properly add a selection border on an entirely selected column', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: 5,\n      totalColumns: 2,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          border: {\n            width: 1,\n            color: 'red'\n          }\n        })\n      }),\n      onCellMouseDown(event, coords) {\n        wt.selections.getCell().clear();\n        wt.selections.getCell().add(coords);\n        wt.draw();\n      }\n    });\n    wt.draw();\n\n    wt.selections.getCell().add(new Walkontable.CellCoords(0, 0));\n    wt.selections.getCell().add(new Walkontable.CellCoords(4, 0));\n    wt.draw(true);\n\n    const $top = $(wt.selections.getCell().getBorder(wt).top);\n    const $right = $(wt.selections.getCell().getBorder(wt).right);\n    const $bottom = $(wt.selections.getCell().getBorder(wt).bottom);\n    const $left = $(wt.selections.getCell().getBorder(wt).left);\n\n    expect($top.css('height')).toBe('1px');\n    expect($top.position().top).toBe(0);\n    expect($top.position().left).toBe(0);\n    expect($right.css('width')).toBe('1px');\n    expect($right.position().top).toBe(0);\n    expect($right.position().left).toBe(49);\n    expect($bottom.css('height')).toBe('1px');\n    expect($bottom.position().top).toBe(115);\n    expect($bottom.position().left).toBe(0);\n    expect($left.css('width')).toBe('1px');\n    expect($left.position().top).toBe(0);\n    expect($left.position().left).toBe(0);\n  });\n\n  it('should add/remove corner to selection when cell is clicked', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: 5,\n      totalColumns: 5,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          border: {\n            width: 2,\n            color: 'green',\n            cornerVisible() {\n              return true;\n            }\n          }\n        }),\n        area: new Walkontable.Selection({}),\n      }),\n      onCellMouseDown(event, coords) {\n        wt.selections.getCell().clear();\n        wt.selections.getCell().add(coords);\n        wt.draw();\n      }\n    });\n    wt.draw();\n\n    const $td1 = $table.find('tbody tr:eq(1) td:eq(0)');\n    const $td2 = $table.find('tbody tr:eq(2) td:eq(1)');\n    const $corner = $(wt.selections.getCell().getBorder(wt).corner);\n\n    $td1.simulate('mousedown');\n\n    expect($corner.css('width')).toBe('6px');\n    expect($corner.css('height')).toBe('6px');\n    expect($corner.position().top).toBe(42);\n    expect($corner.position().left).toBe(45);\n\n    $td2.simulate('mousedown');\n\n    expect($corner.css('width')).toBe('6px');\n    expect($corner.css('height')).toBe('6px');\n    expect($corner.position().top).toBe(65);\n    expect($corner.position().left).toBe(95);\n  });\n\n  it('should draw only one corner if selection is added between overlays', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: 5,\n      totalColumns: 5,\n      fixedColumnsLeft: 2,\n      fixedRowsTop: 2,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          className: 'current',\n        }),\n        area: new Walkontable.Selection({\n          className: 'area',\n          border: {\n            cornerVisible() {\n              return true;\n            }\n          }\n        }),\n      }),\n    });\n\n    wt.selections.createOrGetArea().add(new Walkontable.CellCoords(0, 0));\n    wt.selections.createOrGetArea().add(new Walkontable.CellCoords(2, 2));\n\n    wt.draw();\n\n    const corners = $container.find('.wtBorder.corner:visible');\n\n    expect(corners.length).toBe(1);\n  });\n\n  it('should move the fill handle / corner border to the left, if in the position it would overlap the container (e.g.: far-right)', () => {\n    $container.css({\n      overflow: 'hidden',\n      width: '200px',\n    });\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: 5,\n      totalColumns: 4,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          border: {\n            width: 2,\n            color: 'green',\n            cornerVisible() {\n              return true;\n            }\n          }\n        }),\n        area: new Walkontable.Selection({}),\n      }),\n      onCellMouseDown(event, coords) {\n        wt.selections.getCell().clear();\n        wt.selections.getCell().add(coords);\n        wt.draw();\n      }\n    });\n    wt.draw();\n\n    const $td1 = $table.find('tbody tr:eq(1) td:eq(0)');\n    const $td2 = $table.find('tbody tr:eq(3) td:eq(3)');\n    const $td3 = $table.find('tbody tr:eq(2) td:eq(1)');\n    const $corner = $(wt.selections.getCell().getBorder(wt).corner);\n\n    $td1.simulate('mousedown');\n\n    expect($corner.css('width')).toBe('6px');\n    expect($corner.css('height')).toBe('6px');\n    expect($corner.position().top).toBe(42);\n    expect($corner.position().left).toBe(45);\n    expect($container[0].clientWidth === $container[0].scrollWidth).toBe(true);\n\n    $td2.simulate('mousedown');\n\n    expect($corner.css('width')).toBe('6px');\n    expect($corner.css('height')).toBe('6px');\n    expect($corner.position().top).toBe(88);\n    expect($corner.position().left).toBe(193);\n    expect($container[0].clientWidth === $container[0].scrollWidth).toBe(true);\n\n    $td3.simulate('mousedown');\n\n    expect($corner.css('width')).toBe('6px');\n    expect($corner.css('height')).toBe('6px');\n    expect($corner.position().top).toBe(65);\n    expect($corner.position().left).toBe(95);\n    expect($container[0].clientWidth === $container[0].scrollWidth).toBe(true);\n  });\n\n  it('should move the fill handle / corner border to the top, if in the position it would overlap the container (e.g.: far-bottom)', () => {\n    $container.css({\n      overflow: 'hidden',\n      height: 'auto',\n      marginTop: '2000px',\n    });\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: 5,\n      totalColumns: 1,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          border: {\n            width: 2,\n            color: 'green',\n            cornerVisible() {\n              return true;\n            }\n          }\n        }),\n        area: new Walkontable.Selection({}),\n      }),\n      onCellMouseDown(event, coords) {\n        wt.selections.getCell().clear();\n        wt.selections.getCell().add(coords);\n        wt.draw();\n      }\n    });\n\n    wt.draw();\n\n    const $td = $table.find('tbody tr:last-of-type td:last-of-type');\n    const $corner = $(wt.selections.getCell().getBorder(wt).corner);\n\n    $td.simulate('mousedown');\n\n    wt.draw();\n\n    expect($corner.css('width')).toBe('6px');\n    expect($corner.css('height')).toBe('6px');\n    expect($table.css('height')).toBe('116px');\n    expect($corner.position().top).toBe(109); // table.height - corner.height - corner.borderTop\n    expect($corner.position().left).toBe(45);\n    expect($container[0].clientHeight === $container[0].scrollHeight).toBe(true);\n  });\n\n  it('should move the corner border to the top-left, if is not enough area on the bottom-right corner of container', () => {\n    $container.css({\n      overflow: 'hidden',\n      height: 'auto',\n      width: '50px',\n      marginTop: '2000px',\n      marginLeft: '2000px',\n    });\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: 1,\n      totalColumns: 1,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          border: {\n            width: 2,\n            color: 'green',\n            cornerVisible() {\n              return true;\n            }\n          }\n        }),\n        area: new Walkontable.Selection({}),\n      }),\n      onCellMouseDown(event, coords) {\n        wt.selections.getCell().clear();\n        wt.selections.getCell().add(coords);\n        wt.draw();\n      }\n    });\n\n    wt.draw();\n\n    const $td = $table.find('tbody tr:last-of-type td:last-of-type');\n    const $corner = $(wt.selections.getCell().getBorder(wt).corner);\n\n    $td.simulate('mousedown');\n\n    wt.draw();\n\n    expect($corner.css('width')).toBe('6px');\n    expect($corner.css('height')).toBe('6px');\n    expect($table.css('height')).toBe('24px');\n    expect($corner.position().top).toBe(17); // table.height - corner.height - corner.borderTop\n    expect($corner.position().left).toBe(43);\n    expect($container[0].clientHeight === $container[0].scrollHeight).toBe(true);\n    expect($container[0].clientWidth === $container[0].scrollWidth).toBe(true);\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/border.spec.js","describe('Walkontable.ViewportColumnsCalculator', () => {\n  function allColumns20() {\n    return 20;\n  }\n\n  it('should render first 5 columns in unscrolled container', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(100, 0, 1000, allColumns20);\n    const visibleCalc = new Walkontable.ViewportColumnsCalculator(100, 0, 1000, allColumns20, null, true);\n\n    expect(calc.startColumn).toBe(0);\n    expect(calc.startPosition).toBe(0);\n    expect(calc.endColumn).toBe(4);\n\n    expect(visibleCalc.startColumn).toBe(0);\n    expect(visibleCalc.endColumn).toBe(4);\n  });\n\n  it('should render 6 columns, starting from 3 in container scrolled to half of fourth column', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(100, 70, 1000, allColumns20);\n    const visibleCalc = new Walkontable.ViewportColumnsCalculator(100, 70, 1000, allColumns20, null, true);\n\n    expect(calc.startColumn).toBe(3);\n    expect(calc.startPosition).toBe(60);\n    expect(calc.endColumn).toBe(8);\n\n    expect(visibleCalc.startColumn).toBe(4);\n    expect(visibleCalc.endColumn).toBe(7);\n  });\n\n  it('should render 10 columns, starting from 1 in container scrolled to half of fourth column (with render overrides)', () => {\n    const overrideFn = function(calc) {\n      calc.startColumn -= 2;\n      calc.endColumn += 2;\n    };\n    const calc = new Walkontable.ViewportColumnsCalculator(100, 70, 1000, allColumns20, overrideFn);\n    const visibleCalc = new Walkontable.ViewportColumnsCalculator(100, 70, 1000, allColumns20, null, true);\n\n    expect(calc.startColumn).toBe(1);\n    expect(calc.startPosition).toBe(20);\n    expect(calc.endColumn).toBe(10);\n\n    expect(visibleCalc.startColumn).toBe(4);\n    expect(visibleCalc.endColumn).toBe(7);\n  });\n\n  it('should return number of rendered columns', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(100, 50, 1000, allColumns20);\n    const visibleCalc = new Walkontable.ViewportColumnsCalculator(100, 50, 1000, allColumns20, null, true);\n\n    expect(calc.count).toBe(6);\n\n    expect(visibleCalc.count).toBe(4);\n  });\n\n  it('should render all columns if their size is smaller than viewport', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(200, 0, 8, allColumns20);\n    const visibleCalc = new Walkontable.ViewportColumnsCalculator(200, 0, 8, allColumns20, null, true);\n\n    expect(calc.startColumn).toBe(0);\n    expect(calc.endColumn).toBe(7);\n    expect(calc.count).toBe(8);\n\n    expect(visibleCalc.startColumn).toBe(0);\n    expect(visibleCalc.endColumn).toBe(7);\n    expect(visibleCalc.count).toBe(8);\n  });\n\n  it('should render all columns if their size is exactly the viewport', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(200, 0, 10, allColumns20);\n    const visibleCalc = new Walkontable.ViewportColumnsCalculator(200, 0, 10, allColumns20, null, true);\n\n    expect(calc.startColumn).toBe(0);\n    expect(calc.endColumn).toBe(9);\n    expect(calc.count).toBe(10);\n\n    expect(visibleCalc.startColumn).toBe(0);\n    expect(visibleCalc.endColumn).toBe(9);\n    expect(visibleCalc.count).toBe(10);\n  });\n\n  it('should render all columns if their size is slightly larger than viewport', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(199, 0, 10, allColumns20);\n    const visibleCalc = new Walkontable.ViewportColumnsCalculator(199, 0, 10, allColumns20, null, true);\n\n    expect(calc.startColumn).toBe(0);\n    expect(calc.endColumn).toBe(9);\n    expect(calc.count).toBe(10);\n\n    expect(visibleCalc.startColumn).toBe(0);\n    expect(visibleCalc.endColumn).toBe(8);\n    expect(visibleCalc.count).toBe(9);\n  });\n\n  it('should set null values if total columns is 0', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(200, 0, 0, allColumns20);\n    const visibleCalc = new Walkontable.ViewportColumnsCalculator(200, 0, 0, allColumns20, null, true);\n\n    expect(calc.startColumn).toBe(null);\n    expect(calc.startPosition).toBe(null);\n    expect(calc.endColumn).toBe(null);\n    expect(calc.count).toBe(0);\n\n    expect(visibleCalc.startColumn).toBe(null);\n    expect(visibleCalc.endColumn).toBe(null);\n  });\n\n  it('should set null values if total columns is 0 (with overrideFn provided)', () => {\n    const overrideFn = function(myCalc) {\n      myCalc.startColumn = 0;\n      myCalc.endColumn = 0;\n    };\n    const calc = new Walkontable.ViewportColumnsCalculator(200, 0, 0, allColumns20, overrideFn);\n    const visibleCalc = new Walkontable.ViewportColumnsCalculator(200, 0, 0, allColumns20, null, true);\n\n    expect(calc.startColumn).toBe(null);\n    expect(calc.startPosition).toBe(null);\n    expect(calc.endColumn).toBe(null);\n    expect(calc.count).toBe(0);\n\n    expect(visibleCalc.startColumn).toBe(null);\n    expect(visibleCalc.endColumn).toBe(null);\n  });\n\n  it('should scroll backwards if total columns is reached', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(190, 350, 20, allColumns20);\n    const visibleCalc = new Walkontable.ViewportColumnsCalculator(190, 350, 20, allColumns20, null, true);\n\n    expect(calc.startColumn).toBe(10);\n    expect(calc.startPosition).toBe(200);\n    expect(calc.endColumn).toBe(19);\n    expect(calc.count).toBe(10);\n\n    expect(visibleCalc.startColumn).toBe(11);\n    expect(visibleCalc.endColumn).toBe(19);\n  });\n\n  it('should update stretchAllRatio after refreshStretching call (stretch: all)', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(250, 0, 20, allColumns20, null, true, 'all');\n\n    expect(calc.stretchAllRatio).toBe(0);\n    expect(calc.stretchLastWidth).toBe(0);\n\n    calc.refreshStretching(414);\n\n    expect(calc.stretchAllRatio).toBe(1.035);\n    expect(calc.stretchLastWidth).toBe(0);\n  });\n\n  it('should update stretchAllRatio after refreshStretching call (stretch: last)', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(250, 0, 5, allColumns20, null, true, 'last');\n\n    expect(calc.stretchAllRatio).toBe(0);\n    expect(calc.stretchLastWidth).toBe(0);\n\n    calc.refreshStretching(414);\n\n    expect(calc.stretchAllRatio).toBe(0);\n    expect(calc.stretchLastWidth).toBe(334);\n  });\n\n  it('should return valid stretched column width (stretch: all)', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(250, 0, 5, allColumns20, null, true, 'all');\n\n    expect(calc.getStretchedColumnWidth(0, 50)).toBe(null);\n    expect(calc.needVerifyLastColumnWidth).toBe(true);\n\n    calc.refreshStretching(417);\n\n    expect(calc.getStretchedColumnWidth(0, allColumns20())).toBe(83);\n    expect(calc.getStretchedColumnWidth(1, allColumns20())).toBe(83);\n    expect(calc.getStretchedColumnWidth(2, allColumns20())).toBe(83);\n    expect(calc.getStretchedColumnWidth(3, allColumns20())).toBe(83);\n    expect(calc.needVerifyLastColumnWidth).toBe(true);\n    expect(calc.getStretchedColumnWidth(4, allColumns20())).toBe(85);\n    expect(calc.needVerifyLastColumnWidth).toBe(false);\n  });\n\n  it('should return valid stretched column width (stretch: last)', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(250, 0, 5, allColumns20, null, true, 'last');\n\n    expect(calc.getStretchedColumnWidth(0, 50)).toBe(null);\n\n    calc.refreshStretching(417);\n\n    expect(calc.getStretchedColumnWidth(0, allColumns20())).toBe(null);\n    expect(calc.getStretchedColumnWidth(1, allColumns20())).toBe(null);\n    expect(calc.getStretchedColumnWidth(2, allColumns20())).toBe(null);\n    expect(calc.getStretchedColumnWidth(3, allColumns20())).toBe(null);\n    expect(calc.getStretchedColumnWidth(4, allColumns20())).toBe(337);\n  });\n\n  it('call refreshStretching should clear stretchAllColumnsWidth and needVerifyLastColumnWidth property', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(250, 0, 5, allColumns20, null, true, 'all');\n\n    expect(calc.stretchAllColumnsWidth.length).toBe(0);\n    expect(calc.needVerifyLastColumnWidth).toBe(true);\n\n    calc.refreshStretching(417);\n    calc.getStretchedColumnWidth(0, allColumns20());\n    calc.getStretchedColumnWidth(1, allColumns20());\n    calc.getStretchedColumnWidth(2, allColumns20());\n    calc.getStretchedColumnWidth(3, allColumns20());\n    calc.getStretchedColumnWidth(4, allColumns20());\n\n    expect(calc.stretchAllColumnsWidth.length).toBe(5);\n    expect(calc.needVerifyLastColumnWidth).toBe(false);\n\n    calc.refreshStretching(201);\n\n    expect(calc.stretchAllColumnsWidth.length).toBe(0);\n    expect(calc.needVerifyLastColumnWidth).toBe(true);\n  });\n\n  it('should calculate the number of columns based on a default width, ' +\n    'when the width returned from the function is not a number', () => {\n    const calc = new Walkontable.ViewportColumnsCalculator(200, 0, 1000, () => (void 0 + 1));\n    const visibleCalc = new Walkontable.ViewportColumnsCalculator(200, 0, 1000, () => (void 0 + 1), null, true);\n\n    expect(calc.startColumn).toBe(0);\n    expect(calc.startPosition).toBe(0);\n    expect(calc.endColumn).toBe(3);\n\n    expect(visibleCalc.startColumn).toBe(0);\n    expect(visibleCalc.endColumn).toBe(3);\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/calculator/viewportColumns.spec.js","describe('Walkontable.ViewportRowsCalculator', () => {\n  function allRows20() {\n    return 20;\n  }\n\n  it('should render first 5 rows in unscrolled container', () => {\n    const calc = new Walkontable.ViewportRowsCalculator(100, 0, 1000, allRows20);\n    const visibleCalc = new Walkontable.ViewportRowsCalculator(100, 0, 1000, allRows20, null, true);\n\n    expect(calc.startRow).toBe(0);\n    expect(calc.startPosition).toBe(0);\n    expect(calc.endRow).toBe(4);\n\n    expect(visibleCalc.startRow).toBe(0);\n    expect(visibleCalc.endRow).toBe(4);\n  });\n\n  it('should render 6 rows, starting from 3 in container scrolled to half of fourth row', () => {\n    const calc = new Walkontable.ViewportRowsCalculator(100, 70, 1000, allRows20);\n    const visibleCalc = new Walkontable.ViewportRowsCalculator(100, 70, 1000, allRows20, null, true);\n\n    expect(calc.startRow).toBe(3);\n    expect(calc.startPosition).toBe(60);\n    expect(calc.endRow).toBe(8);\n\n    expect(visibleCalc.startRow).toBe(4);\n    expect(visibleCalc.endRow).toBe(7);\n  });\n\n  it('should render 10 rows, starting from 1 in container scrolled to half of fourth row (with render overrides)', () => {\n    const overrideFn = function(calc) {\n      calc.startRow -= 2;\n      calc.endRow += 2;\n    };\n    const calc = new Walkontable.ViewportRowsCalculator(100, 70, 1000, allRows20, overrideFn);\n    const visibleCalc = new Walkontable.ViewportRowsCalculator(100, 70, 1000, allRows20, null, true);\n\n    expect(calc.startRow).toBe(1);\n    expect(calc.startPosition).toBe(20);\n    expect(calc.endRow).toBe(10);\n\n    expect(visibleCalc.startRow).toBe(4);\n    expect(visibleCalc.endRow).toBe(7);\n  });\n\n  it('should return number of rendered rows', () => {\n    const calc = new Walkontable.ViewportRowsCalculator(100, 50, 1000, allRows20);\n    const visibleCalc = new Walkontable.ViewportRowsCalculator(100, 50, 1000, allRows20, null, true);\n\n    expect(calc.count).toBe(6);\n\n    expect(visibleCalc.count).toBe(4);\n  });\n\n  it('should render all rows if their size is smaller than viewport', () => {\n    const calc = new Walkontable.ViewportRowsCalculator(200, 0, 8, allRows20);\n    const visibleCalc = new Walkontable.ViewportRowsCalculator(200, 0, 8, allRows20, null, true);\n\n    expect(calc.startRow).toBe(0);\n    expect(calc.endRow).toBe(7);\n    expect(calc.count).toBe(8);\n\n    expect(visibleCalc.startRow).toBe(0);\n    expect(visibleCalc.endRow).toBe(7);\n    expect(visibleCalc.count).toBe(8);\n  });\n\n  it('should render all rows if their size is exactly the viewport', () => {\n    const calc = new Walkontable.ViewportRowsCalculator(200, 0, 10, allRows20);\n    const visibleCalc = new Walkontable.ViewportRowsCalculator(200, 0, 10, allRows20, null, true);\n\n    expect(calc.startRow).toBe(0);\n    expect(calc.endRow).toBe(9);\n    expect(calc.count).toBe(10);\n\n    expect(visibleCalc.startRow).toBe(0);\n    expect(visibleCalc.endRow).toBe(9);\n    expect(visibleCalc.count).toBe(10);\n  });\n\n  it('should render all rows if their size is slightly larger than viewport', () => {\n    const calc = new Walkontable.ViewportRowsCalculator(199, 0, 10, allRows20);\n    const visibleCalc = new Walkontable.ViewportRowsCalculator(199, 0, 10, allRows20, null, true);\n\n    expect(calc.startRow).toBe(0);\n    expect(calc.endRow).toBe(9);\n    expect(calc.count).toBe(10);\n\n    expect(visibleCalc.startRow).toBe(0);\n    expect(visibleCalc.endRow).toBe(8);\n    expect(visibleCalc.count).toBe(9);\n  });\n\n  it('should set null values if total rows is 0', () => {\n    const calc = new Walkontable.ViewportRowsCalculator(200, 0, 0, allRows20);\n    const visibleCalc = new Walkontable.ViewportRowsCalculator(200, 0, 0, allRows20, null, true);\n\n    expect(calc.startRow).toBe(null);\n    expect(calc.startPosition).toBe(null);\n    expect(calc.endRow).toBe(null);\n    expect(calc.count).toBe(0);\n\n    expect(visibleCalc.startRow).toBe(null);\n    expect(visibleCalc.endRow).toBe(null);\n  });\n\n  it('should set null values if total rows is 0 (with overrideFn provided)', () => {\n    const overrideFn = function(myCalc) {\n      myCalc.startRow = 0;\n      myCalc.endRow = 0;\n    };\n    const calc = new Walkontable.ViewportRowsCalculator(200, 0, 0, allRows20, overrideFn);\n    const visibleCalc = new Walkontable.ViewportRowsCalculator(200, 0, 0, allRows20, null, true);\n\n    expect(calc.startRow).toBe(null);\n    expect(calc.startPosition).toBe(null);\n    expect(calc.endRow).toBe(null);\n    expect(calc.count).toBe(0);\n\n    expect(visibleCalc.startRow).toBe(null);\n    expect(visibleCalc.endRow).toBe(null);\n  });\n\n  it('should scroll backwards if total rows is reached', () => {\n    const calc = new Walkontable.ViewportRowsCalculator(190, 350, 20, allRows20);\n    const visibleCalc = new Walkontable.ViewportRowsCalculator(190, 350, 20, allRows20, null, true);\n\n    expect(calc.startRow).toBe(10);\n    expect(calc.startPosition).toBe(200);\n    expect(calc.endRow).toBe(19);\n    expect(calc.count).toBe(10);\n\n    expect(visibleCalc.startRow).toBe(11);\n    expect(visibleCalc.endRow).toBe(19);\n  });\n\n  it('should calculate the number of rows based on a default height, ' +\n    'when the height returned from the function is not a number', () => {\n    const calc = new Walkontable.ViewportRowsCalculator(100, 0, 1000, () => (void 0 + 1));\n    const visibleCalc = new Walkontable.ViewportRowsCalculator(100, 0, 1000, () => (void 0 + 1), null, true);\n\n    expect(calc.startRow).toBe(0);\n    expect(calc.startPosition).toBe(0);\n    expect(calc.endRow).toBe(4);\n\n    expect(visibleCalc.startRow).toBe(0);\n    expect(visibleCalc.endRow).toBe(3);\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/calculator/viewportRows.spec.js","describe('Walkontable.CellCoords', () => {\n  describe('isValid', () => {\n\n    const table = document.createElement('table');\n    const wrapper = document.createElement('div');\n    const container = document.createElement('div');\n    wrapper.appendChild(container);\n    container.appendChild(table);\n\n    const wot = new Walkontable.Core({\n      table,\n      data: [],\n      totalRows: 10,\n      totalColumns: 5\n    });\n\n    it('should be false if one of the arguments is smaller than 0', () => {\n      let cellCoords = new Walkontable.CellCoords(-1, 0);\n      let result = cellCoords.isValid(wot);\n      expect(result).toBe(false);\n\n      cellCoords = new Walkontable.CellCoords(0, -1);\n      result = cellCoords.isValid(wot);\n      expect(result).toBe(false);\n    });\n\n    it('should be true if row is within the total number of rows', () => {\n      const cellCoords = new Walkontable.CellCoords(9, 1);\n      const result = cellCoords.isValid(wot);\n      expect(result).toBe(true);\n    });\n\n    it('should be false if row is greater than total number of rows', () => {\n      const cellCoords = new Walkontable.CellCoords(10, 1);\n      const result = cellCoords.isValid(wot);\n      expect(result).toBe(false);\n    });\n\n    it('should be true if column is within the total number of columns', () => {\n      const cellCoords = new Walkontable.CellCoords(1, 4);\n      const result = cellCoords.isValid(wot);\n      expect(result).toBe(true);\n    });\n\n    it('should be false if column is greater than total number of columns', () => {\n      const cellCoords = new Walkontable.CellCoords(1, 5);\n      const result = cellCoords.isValid(wot);\n      expect(result).toBe(false);\n    });\n  });\n\n  describe('isEqual', () => {\n    it('should be equal to itself', () => {\n      const cellCoords = new Walkontable.CellCoords(1, 1);\n      const result = cellCoords.isEqual(cellCoords);\n      expect(result).toBe(true);\n    });\n\n    it('should be equal to another instance with the same row and column', () => {\n      const cellCoords = new Walkontable.CellCoords(1, 1);\n      const cellCoords2 = new Walkontable.CellCoords(1, 1);\n      const result = cellCoords.isEqual(cellCoords2);\n      expect(result).toBe(true);\n    });\n\n    it('should not be equal to an instance with different row or column', () => {\n      const cellCoords = new Walkontable.CellCoords(1, 1);\n      const cellCoords2 = new Walkontable.CellCoords(2, 1);\n      const result = cellCoords.isEqual(cellCoords2);\n      expect(result).toBe(false);\n    });\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/cell/coords.spec.js","describe('Walkontable.CellRange', () => {\n  describe('getAll', () => {\n    it('should get all cells in range', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(3, 3);\n      const range = new Walkontable.CellRange(from, from, to);\n      const all = range.getAll();\n      expect(all.length).toBe(9);\n      expect(all[0].row).toBe(from.row);\n      expect(all[0].col).toBe(from.col);\n      expect(all[1].row).toBe(1);\n      expect(all[1].col).toBe(2);\n      expect(all[8].row).toBe(to.row);\n      expect(all[8].col).toBe(to.col);\n    });\n\n    it('should get all cells in range (reverse order)', () => {\n      const from = new Walkontable.CellCoords(3, 3);\n      const to = new Walkontable.CellCoords(1, 1);\n      const range = new Walkontable.CellRange(from, from, to);\n      const all = range.getAll();\n      expect(all.length).toBe(9);\n      expect(all[0].row).toBe(to.row);\n      expect(all[0].col).toBe(to.col);\n      expect(all[1].row).toBe(1);\n      expect(all[1].col).toBe(2);\n      expect(all[8].row).toBe(from.row);\n      expect(all[8].col).toBe(from.col);\n    });\n  });\n\n  describe('getInner', () => {\n    it('should get cells in range excluding from and to', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(3, 3);\n      const range = new Walkontable.CellRange(from, from, to);\n      const inner = range.getInner();\n      expect(inner.length).toBe(7);\n      expect(inner[1].row).toBe(1);\n      expect(inner[1].col).toBe(3);\n    });\n\n    it('should get cells in range excluding from and to (reverse order)', () => {\n      const from = new Walkontable.CellCoords(3, 3);\n      const to = new Walkontable.CellCoords(1, 1);\n      const range = new Walkontable.CellRange(from, from, to);\n      const inner = range.getInner();\n      expect(inner.length).toBe(7);\n      expect(inner[1].row).toBe(1);\n      expect(inner[1].col).toBe(3);\n    });\n  });\n\n  describe('includes', () => {\n    it('should return true if range is a single cell and the same cell is given', () => {\n      const from = new Walkontable.CellCoords(0, 0);\n      const to = new Walkontable.CellCoords(0, 0);\n      const range = new Walkontable.CellRange(from, from, to);\n      expect(range.includes(new Walkontable.CellCoords(0, 0))).toBe(true);\n    });\n\n    it('should return true if given cell is within the range', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(3, 3);\n      const range = new Walkontable.CellRange(from, from, to);\n      expect(range.includes(new Walkontable.CellCoords(1, 1))).toBe(true);\n      expect(range.includes(new Walkontable.CellCoords(3, 1))).toBe(true);\n      expect(range.includes(new Walkontable.CellCoords(3, 3))).toBe(true);\n      expect(range.includes(new Walkontable.CellCoords(1, 3))).toBe(true);\n      expect(range.includes(new Walkontable.CellCoords(2, 2))).toBe(true);\n      expect(range.includes(new Walkontable.CellCoords(1, 2))).toBe(true);\n      expect(range.includes(new Walkontable.CellCoords(2, 1))).toBe(true);\n    });\n\n    it('should return false if given cell outside the range', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(3, 3);\n      const range = new Walkontable.CellRange(from, from, to);\n      expect(range.includes(new Walkontable.CellCoords(0, 0))).toBe(false);\n      expect(range.includes(new Walkontable.CellCoords(4, 4))).toBe(false);\n      expect(range.includes(new Walkontable.CellCoords(1, 4))).toBe(false);\n      expect(range.includes(new Walkontable.CellCoords(4, 1))).toBe(false);\n      expect(range.includes(new Walkontable.CellCoords(-1, -1))).toBe(false);\n    });\n  });\n\n  describe('includesRange', () => {\n    describe('B has more than one cell', () => {\n      /*\n       +----------+\n       |  a       |\n       | +------+ |\n       | |    b | |\n       | |      | |\n       | +------+ |\n       +----------+\n       */\n      it('B is included in A, none of borders touch each other', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 1);\n        const bBottomRight = new Walkontable.CellCoords(4, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +----------+\n       |  b       |\n       | +------+ |\n       | |   a  | |\n       | |      | |\n       | +------+ |\n       +----------+\n       */\n      it('A is included in B, none of borders touch each other', () => {\n        const aTopLeft = new Walkontable.CellCoords(1, 1);\n        const aBottomRight = new Walkontable.CellCoords(4, 4);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(false);\n      });\n\n      /*\n       +-----------+\n       | a |   b | |\n       |   |     | |\n       |   +-----+ |\n       +-----------+\n       */\n      it('B is included in A, top borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 1);\n        const bBottomRight = new Walkontable.CellCoords(4, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +---------+\n       | a |   b |\n       |   |     |\n       |   +-----|\n       |         |\n       +---------+\n       */\n      it('B is included in A, top and right borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 1);\n        const bBottomRight = new Walkontable.CellCoords(4, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +---------+\n       |   +-----|\n       | a |   b |\n       |   |     |\n       |   +-----|\n       +---------+\n       */\n      it('B is included in A, right borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 1);\n        const bBottomRight = new Walkontable.CellCoords(4, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +---------+\n       |   +-----|\n       | a |   b |\n       |   |     |\n       +---------+\n       */\n      it('B is included in A, bottom and right borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 1);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +-----------+\n       |   +-----+ |\n       | a |   b | |\n       |   |     | |\n       +-----------+\n       */\n      it('B is included in A, bottom borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 1);\n        const bBottomRight = new Walkontable.CellCoords(5, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +-----------+\n       |-----+   a |\n       |   b |     |\n       |     |     |\n       +-----------+\n       */\n      it('B is included in A, bottom and left borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +-----------+\n       |-----+   a |\n       |   b |     |\n       |     |     |\n       |-----+     |\n       +-----------+\n       */\n      it('B is included in A, left borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 0);\n        const bBottomRight = new Walkontable.CellCoords(4, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +-----------+\n       |   b |   a |\n       |     |     |\n       |-----+     |\n       +-----------+\n       */\n      it('B is included in A, top and left borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(4, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +------------+\n       |  a |   b | |\n       |    |     | |\n       +------------+\n       */\n      it('B is included in A, top and bottom borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 1);\n        const bBottomRight = new Walkontable.CellCoords(5, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +----------+\n       |  a |   b |\n       |    |     |\n       +----------+\n       */\n      it('B is included in A, top, right and bottom borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 1);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +----------+\n       |  b |   a |\n       |    |     |\n       +----------+\n       */\n      it('B is included in A, top, left and bottom borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +----------+\n       | a        |\n       |----------|\n       |  b       |\n       |----------|\n       +----------+\n       */\n      it('B is included in A, left and right borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 0);\n        const bBottomRight = new Walkontable.CellCoords(4, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +----------+\n       | a        |\n       |----------|\n       |  b       |\n       +----------+\n       */\n      it('B is included in A, left, bottom and right borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n      /*\n       +----------+\n       | b        |\n       |----------|\n       |  a       |\n       +----------+\n       */\n      it('B is included in A, left, top and right borders touch', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(4, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n    });\n    describe('B has exactly one cell', () => {\n\n      /*\n       +----------+\n       |  a       |\n       | +------+ |\n       | |    b | |\n       | |      | |\n       | +------+ |\n       +----------+\n       */\n      it('B is included in A, none of borders touch each other', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 1);\n        const bBottomRight = new Walkontable.CellCoords(1, 1);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.includesRange(b)).toBe(true);\n      });\n\n    });\n  });\n\n  describe('expand', () => {\n    it('should not change range if expander to a cell that fits within the range', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(3, 3);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      const topLeft = range.getTopLeftCorner();\n      const bottomRight = range.getBottomRightCorner();\n\n      const expander = new Walkontable.CellCoords(3, 1);\n      const res = range.expand(expander);\n      expect(res).toBe(false);\n      const topLeft2 = range.getTopLeftCorner();\n      const bottomRight2 = range.getBottomRightCorner();\n      expect(topLeft2).toEqual(topLeft);\n      expect(bottomRight2).toEqual(bottomRight);\n    });\n\n    it('should change range if expander to a cell outside of the cell range', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(3, 3);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      const topLeft = range.getTopLeftCorner();\n\n      const expander = new Walkontable.CellCoords(4, 4);\n      const res = range.expand(expander);\n      expect(res).toBe(true);\n      const topLeft2 = range.getTopLeftCorner();\n      const bottomRight2 = range.getBottomRightCorner();\n      expect(topLeft2).toEqual(topLeft);\n      expect(bottomRight2).toEqual(expander);\n    });\n\n    it('should change range if expander to a cell outside of the cell range (inverted)', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(3, 3);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      const topLeft = range.getTopLeftCorner();\n\n      const expander = new Walkontable.CellCoords(4, 4);\n      const res = range.expand(expander);\n      expect(res).toBe(true);\n      const topLeft2 = range.getTopLeftCorner();\n      const bottomRight2 = range.getBottomRightCorner();\n      expect(topLeft2).toEqual(topLeft);\n      expect(bottomRight2).toEqual(expander);\n    });\n\n    it('should change range if expander to a cell outside of the cell range (bottom left)', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(3, 3);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      const expander = new Walkontable.CellCoords(3, 0);\n      const res = range.expand(expander);\n      expect(res).toBe(true);\n      const topLeft2 = range.getTopLeftCorner();\n      const bottomRight2 = range.getBottomRightCorner();\n      expect(topLeft2).toEqual(new Walkontable.CellCoords(1, 0));\n      expect(bottomRight2).toEqual(new Walkontable.CellCoords(3, 3));\n    });\n\n    it('should change range if expander to a cell outside of the cell range (inverted top right)', () => {\n      const from = new Walkontable.CellCoords(2, 0);\n      const to = new Walkontable.CellCoords(1, 0);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      const expander = new Walkontable.CellCoords(1, 1);\n      const res = range.expand(expander);\n      expect(res).toBe(true);\n      const topLeft2 = range.getTopLeftCorner();\n      const bottomRight2 = range.getBottomRightCorner();\n      expect(topLeft2).toEqual(new Walkontable.CellCoords(1, 0));\n      expect(bottomRight2).toEqual(new Walkontable.CellCoords(2, 1));\n    });\n\n    it('should change range if expander to a cell outside of the cell range (inverted bottom left)', () => {\n      const from = new Walkontable.CellCoords(2, 1);\n      const to = new Walkontable.CellCoords(1, 1);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      const expander = new Walkontable.CellCoords(3, 0);\n      const res = range.expand(expander);\n      expect(res).toBe(true);\n      const topLeft2 = range.getTopLeftCorner();\n      const bottomRight2 = range.getBottomRightCorner();\n      expect(topLeft2).toEqual(new Walkontable.CellCoords(1, 0));\n      expect(bottomRight2).toEqual(new Walkontable.CellCoords(3, 1));\n    });\n  });\n\n  describe('overlaps', () => {\n    describe('positive', () => {\n      /*\n             +-------+\n             |       |\n             |   b   |\n       +-------+     |\n       |     +-|-----+\n       |   a   |\n       |       |\n       +-------+\n       */\n      it('overlapping from NE', () => {\n        const aTopLeft = new Walkontable.CellCoords(3, 0);\n        const aBottomRight = new Walkontable.CellCoords(8, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 3);\n        const bBottomRight = new Walkontable.CellCoords(5, 8);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n       +---------+\n       |      +-------+\n       |      |  |    |\n       |  a   |  |  b |\n       |      |  |    |\n       |      +-------+\n       +---------+\n       */\n      it('overlapping from E', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 3);\n        const bBottomRight = new Walkontable.CellCoords(4, 6);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n       +--------+\n       |        |\n       |  a     |\n       |    +---------+\n       |    |   |     |\n       +----|---+     |\n            |      b  |\n            |         |\n            +---------+\n       */\n      it('overlapping from SE', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(3, 3);\n        const bBottomRight = new Walkontable.CellCoords(8, 8);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n       +---------+\n       |    a    |\n       | +-----+ |\n       +-|-----|-+\n         |  b  |\n         +-----+\n       */\n      it('overlapping from S', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(3, 1);\n        const bBottomRight = new Walkontable.CellCoords(6, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n           +--------+\n           |      a |\n       +--------+   |\n       |   |    |   |\n       |   +----|---+\n       | b      |\n       +--------+\n       */\n      it('overlapping from SW', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 3);\n        const aBottomRight = new Walkontable.CellCoords(5, 8);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(3, 0);\n        const bBottomRight = new Walkontable.CellCoords(8, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n           +-------+\n       +---|--+    |\n       |   |  |    |\n       | b |  |  a |\n       |   |  |    |\n       +---|--+    |\n           +-------+\n       */\n      it('overlapping from S', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 3);\n        const aBottomRight = new Walkontable.CellCoords(5, 8);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 1);\n        const bBottomRight = new Walkontable.CellCoords(4, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n       +------+\n       | b    |\n       |   +-------+\n       |   |  |    |\n       +---|--+  a |\n           |       |\n           +-------+\n       */\n      it('overlapping from NW', () => {\n        const aTopLeft = new Walkontable.CellCoords(3, 3);\n        const aBottomRight = new Walkontable.CellCoords(8, 8);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n       +---------+\n       |    b    |\n       | +-----+ |\n       +-|-----|-+\n         |  a  |\n         +-----+\n       */\n      it('overlapping from N', () => {\n        const aTopLeft = new Walkontable.CellCoords(3, 1);\n        const aBottomRight = new Walkontable.CellCoords(6, 4);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n       +----------+\n       |  a       |\n       | +------+ |\n       | |    b | |\n       | |      | |\n       | +------+ |\n       +----------+\n       */\n      it('overlapping when includes', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 1);\n        const bBottomRight = new Walkontable.CellCoords(4, 4);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n       +----------+\n       |  b       |\n       | +------+ |\n       | |    a | |\n       | |      | |\n       | +------+ |\n       +----------+\n       */\n      it('overlapping when included', () => {\n        const aTopLeft = new Walkontable.CellCoords(1, 1);\n        const aBottomRight = new Walkontable.CellCoords(4, 4);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n\n       b-> +----------+\n           |  a       |\n           |          |\n           |          |\n           +----------+\n       */\n      it('overlapping when A includes B and B has only one cell, and this cell is A\\'s top left corner', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(0, 0);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n\n       +----------+ <- b\n       |  a       |\n       |          |\n       |          |\n       +----------+\n       */\n      it('overlapping when A includes B and B has only one cell, and this cell is A\\'s top right corner', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 5);\n        const bBottomRight = new Walkontable.CellCoords(0, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n\n           +----------+\n           |  a       |\n           |          |\n           |          |\n      b -> +----------+\n       */\n      it('overlapping when A includes B and B has only one cell, and this cell is A\\'s bottom left corner', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(5, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 0);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n\n       +----------+\n       |  a       |\n       |          |\n       |          |\n       +----------+ <- b\n       */\n      it('overlapping when A includes B and B has only one cell, and this cell is A\\'s bottom right corner', () => {\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(5, 5);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n      });\n\n      /*\n            +----+\n            |b   |\n       +----+----+\n       |   a|\n       +----+\n       */\n      it('overlapping by touching from NE', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(5, 0);\n        const aBottomRight = new Walkontable.CellCoords(10, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 5);\n        const bBottomRight = new Walkontable.CellCoords(5, 10);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n\n      });\n\n      /*\n       +----+----+\n       |   a|   b|\n       +----+----+\n       */\n      it('overlapping by touching from E', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 5);\n        const bBottomRight = new Walkontable.CellCoords(5, 10);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n\n      });\n\n      /*\n       +----+\n       |   a|\n       +----+----+\n            |   b|\n            +----+\n       */\n      it('overlapping by touching from SE', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(5, 5);\n        const bBottomRight = new Walkontable.CellCoords(10, 10);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n\n      });\n\n      /*\n       +----+\n       |   a|\n       +----+\n       |   b|\n       +----+\n       */\n      it('overlapping by touching from S', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(5, 5);\n        const bBottomRight = new Walkontable.CellCoords(10, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n\n      });\n\n      /*\n            +----+\n            |   a|\n       +----+----+\n       |   b|\n       +----+\n       */\n      it('overlapping by touching from SW', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(0, 5);\n        const aBottomRight = new Walkontable.CellCoords(5, 10);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(5, 0);\n        const bBottomRight = new Walkontable.CellCoords(10, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n\n      });\n\n      /*\n       +----+----+\n       |   b|   a|\n       +----+----+\n       */\n      it('overlapping by touching from W', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(0, 5);\n        const aBottomRight = new Walkontable.CellCoords(5, 10);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n\n      });\n\n      /*\n       +----+\n       |   b|\n       +----+----+\n            |   a|\n            +----+\n       */\n      it('overlapping by touching from NW', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(5, 5);\n        const aBottomRight = new Walkontable.CellCoords(10, 10);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n\n      });\n\n      /*\n       +----+\n       |   b|\n       +----+\n       |   a|\n       +----+\n       */\n      it('overlapping by touching from E', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(5, 0);\n        const aBottomRight = new Walkontable.CellCoords(10, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(true);\n\n      });\n\n    });\n\n    describe('negative', () => {\n      /*\n             +---+\n             |  b|\n             +---+\n       +------+\n       |      |\n       |  a   |\n       |      |\n       +------+\n       */\n      it('not overlapping from NE', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(6, 0);\n        const aBottomRight = new Walkontable.CellCoords(11, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 3);\n        const bBottomRight = new Walkontable.CellCoords(5, 8);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(false);\n\n      });\n\n      /*\n       +------+\n       |      | +--+\n       |   a  | | b|\n       |      | +--+\n       +------+\n       */\n      it('not overlapping from E', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 6);\n        const bBottomRight = new Walkontable.CellCoords(4, 9);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(false);\n\n      });\n\n      /*\n       +----+\n       |a   |\n       |    | +----+\n       +----+ |b   |\n              |    |\n              +----+\n       */\n      it('not overlapping from SE', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(1, 6);\n        const bBottomRight = new Walkontable.CellCoords(4, 9);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(false);\n\n      });\n\n      /*\n       +----+\n       |a   |\n       |    |\n       +----+\n       +----+\n       |b   |\n       |    |\n       +----+\n       */\n      it('not overlapping from S', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(0, 0);\n        const aBottomRight = new Walkontable.CellCoords(5, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(6, 0);\n        const bBottomRight = new Walkontable.CellCoords(11, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(false);\n\n      });\n\n      /*\n           +----+\n           |a   |\n           |    |\n           +----+\n       +----+\n       |b   |\n       |    |\n       +----+\n       */\n      it('not overlapping from SW', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(0, 3);\n        const aBottomRight = new Walkontable.CellCoords(5, 8);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(6, 0);\n        const bBottomRight = new Walkontable.CellCoords(11, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(false);\n\n      });\n\n      /*\n            +------+\n       +--+ |      |\n       | b| |   a  |\n       +--+ |      |\n            +------+\n       */\n      it('not overlapping from W', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(0, 6);\n        const aBottomRight = new Walkontable.CellCoords(5, 11);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(3, 0);\n        const bBottomRight = new Walkontable.CellCoords(6, 3);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(false);\n\n      });\n\n      /*\n       +----+\n       |b   |\n       |    | +----+\n       +----+ | a  |\n              |    |\n              +----+\n       */\n      it('not overlapping from NW', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(0, 6);\n        const aBottomRight = new Walkontable.CellCoords(3, 11);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(false);\n\n      });\n\n      /*\n       +----+\n       |b   |\n       +----+\n       +----+\n       |   a|\n       +----+\n       */\n      it('not overlapping from N', () => {\n\n        const aTopLeft = new Walkontable.CellCoords(6, 0);\n        const aBottomRight = new Walkontable.CellCoords(11, 5);\n        const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n        const bTopLeft = new Walkontable.CellCoords(0, 0);\n        const bBottomRight = new Walkontable.CellCoords(5, 5);\n        const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n        expect(a.overlaps(b)).toBe(false);\n      });\n    });\n  });\n\n  describe('expand by range', () => {\n    it('should not expand range A with range B if A includes B', () => {\n      const aTopLeft = new Walkontable.CellCoords(0, 0);\n      const aBottomRight = new Walkontable.CellCoords(5, 5);\n      const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n      const bTopLeft = new Walkontable.CellCoords(2, 2);\n      const bBottomRight = new Walkontable.CellCoords(4, 4);\n      const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n      expect(a.expandByRange(b)).toBe(false);\n\n      expect(a.getTopLeftCorner().row).toEqual(0);\n      expect(a.getTopLeftCorner().col).toEqual(0);\n      expect(a.getBottomRightCorner().row).toEqual(5);\n      expect(a.getBottomRightCorner().col).toEqual(5);\n    });\n\n    it('should not expand range A with range B if A and B don\\'t overlap', () => {\n      const aTopLeft = new Walkontable.CellCoords(0, 0);\n      const aBottomRight = new Walkontable.CellCoords(5, 5);\n      const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n      const bTopLeft = new Walkontable.CellCoords(10, 10);\n      const bBottomRight = new Walkontable.CellCoords(15, 15);\n      const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n      expect(a.expandByRange(b)).toBe(false);\n\n      expect(a.getTopLeftCorner().row).toEqual(0);\n      expect(a.getTopLeftCorner().col).toEqual(0);\n      expect(a.getBottomRightCorner().row).toEqual(5);\n      expect(a.getBottomRightCorner().col).toEqual(5);\n    });\n\n    it('should not expand range A with range B', () => {\n      const aTopLeft = new Walkontable.CellCoords(0, 0);\n      const aBottomRight = new Walkontable.CellCoords(5, 5);\n      const a = new Walkontable.CellRange(aTopLeft, aTopLeft, aBottomRight);\n\n      const bTopLeft = new Walkontable.CellCoords(2, 2);\n      const bBottomRight = new Walkontable.CellCoords(7, 7);\n      const b = new Walkontable.CellRange(bTopLeft, bTopLeft, bBottomRight);\n\n      expect(a.expandByRange(b)).toBe(true);\n\n      expect(a.getTopLeftCorner().row).toEqual(0);\n      expect(a.getTopLeftCorner().col).toEqual(0);\n      expect(a.getBottomRightCorner().row).toEqual(7);\n      expect(a.getBottomRightCorner().col).toEqual(7);\n    });\n  });\n\n  describe('forAll', () => {\n    it('callback should be called for all cells in the range', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(3, 3);\n      const range = new Walkontable.CellRange(from, from, to);\n      const forAllCallback = jasmine.createSpy('beforeColumnSortHandler');\n      range.forAll(forAllCallback);\n\n      expect(forAllCallback.calls.count()).toBe(9);\n    });\n\n    it('callback should be called with row, column parameters', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(2, 2);\n      const range = new Walkontable.CellRange(from, from, to);\n      const rows = [];\n      const cols = [];\n      range.forAll((row, col) => {\n        rows.push(row);\n        cols.push(col);\n      });\n      expect(rows).toEqual([1, 1, 2, 2]);\n      expect(cols).toEqual([1, 2, 1, 2]);\n    });\n\n    it('iteration should be interrupted when callback returns false', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(2, 2);\n      const range = new Walkontable.CellRange(from, from, to);\n      let callCount = 0;\n      range.forAll(() => {\n        callCount += 1;\n        if (callCount === 2) {\n          return false;\n        }\n      });\n      expect(callCount).toBe(2);\n    });\n  });\n\n  describe('direction', () => {\n    it('should properly change direction on NW-SE', () => {\n      const from = new Walkontable.CellCoords(2, 1);\n      const to = new Walkontable.CellCoords(1, 2);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      expect(range.getDirection()).toBe('SW-NE');\n\n      range.setDirection('NW-SE');\n\n      expect(range.getDirection()).toBe('NW-SE');\n      expect(range.from.row).toBe(1);\n      expect(range.from.col).toBe(1);\n      expect(range.to.row).toBe(2);\n      expect(range.to.col).toBe(2);\n    });\n\n    it('should properly change direction on NE-SW', () => {\n      const from = new Walkontable.CellCoords(2, 1);\n      const to = new Walkontable.CellCoords(1, 2);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      expect(range.getDirection()).toBe('SW-NE');\n\n      range.setDirection('NE-SW');\n\n      expect(range.getDirection()).toBe('NE-SW');\n      expect(range.from.row).toBe(1);\n      expect(range.from.col).toBe(2);\n      expect(range.to.row).toBe(2);\n      expect(range.to.col).toBe(1);\n    });\n\n    it('should properly change direction on SE-NW', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(2, 2);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      expect(range.getDirection()).toBe('NW-SE');\n\n      range.setDirection('SE-NW');\n\n      expect(range.getDirection()).toBe('SE-NW');\n      expect(range.from.row).toBe(2);\n      expect(range.from.col).toBe(2);\n      expect(range.to.row).toBe(1);\n      expect(range.to.col).toBe(1);\n    });\n\n    it('should properly change direction on SW-NE', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(2, 2);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      expect(range.getDirection()).toBe('NW-SE');\n\n      range.setDirection('SW-NE');\n\n      expect(range.getDirection()).toBe('SW-NE');\n      expect(range.from.row).toBe(2);\n      expect(range.from.col).toBe(1);\n      expect(range.to.row).toBe(1);\n      expect(range.to.col).toBe(2);\n    });\n\n    it('should properly return the vertical direction of a range', () => {\n      let from = new Walkontable.CellCoords(1, 1);\n      let to = new Walkontable.CellCoords(2, 2);\n      let range = new Walkontable.CellRange(from, from, to);\n\n      expect(range.getVerticalDirection()).toEqual('N-S');\n\n      from = new Walkontable.CellCoords(2, 2);\n      to = new Walkontable.CellCoords(1, 1);\n      range = new Walkontable.CellRange(from, from, to);\n\n      expect(range.getVerticalDirection()).toEqual('S-N');\n    });\n\n    it('should properly return the horizontal direction of a range', () => {\n      let from = new Walkontable.CellCoords(1, 1);\n      let to = new Walkontable.CellCoords(2, 2);\n      let range = new Walkontable.CellRange(from, from, to);\n\n      expect(range.getHorizontalDirection()).toEqual('W-E');\n\n      from = new Walkontable.CellCoords(2, 2);\n      to = new Walkontable.CellCoords(1, 1);\n      range = new Walkontable.CellRange(from, from, to);\n\n      expect(range.getHorizontalDirection()).toEqual('E-W');\n    });\n\n    it('should flip the direction vertically when using the `flipDirectionVertically` method', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(2, 2);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      range.flipDirectionVertically();\n\n      expect(range.from.row).toEqual(2);\n      expect(range.from.col).toEqual(1);\n      expect(range.to.row).toEqual(1);\n      expect(range.to.col).toEqual(2);\n\n      expect(range.getDirection()).toEqual('SW-NE');\n    });\n\n    it('should flip the direction horizontally when using the `flipDirectionHorizontally` method', () => {\n      const from = new Walkontable.CellCoords(1, 1);\n      const to = new Walkontable.CellCoords(2, 2);\n      const range = new Walkontable.CellRange(from, from, to);\n\n      range.flipDirectionHorizontally();\n\n      expect(range.from.row).toEqual(1);\n      expect(range.from.col).toEqual(2);\n      expect(range.to.row).toEqual(2);\n      expect(range.to.col).toEqual(1);\n\n      expect(range.getDirection()).toEqual('NE-SW');\n    });\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/cell/range.spec.js","describe('WalkontableCore', () => {\n  let $table;\n  let $container;\n  let $wrapper;\n  const debug = false;\n\n  beforeEach(() => {\n    $wrapper = $('<div></div>').css({ overflow: 'hidden' });\n    $container = $('<div></div>');\n    $table = $('<table></table>'); // create a table that is not attached to document\n    $wrapper.append($container);\n    $container.append($table);\n    $wrapper.appendTo('body');\n    createDataArray(100, 4);\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n\n    $wrapper.remove();\n  });\n\n  it('first row should have the same text as in data source', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n    const TDs = $table.find('tbody tr:first td');\n    expect(TDs[0].innerHTML).toBe('0');\n    expect(TDs[1].innerHTML).toBe('a');\n  });\n\n  it('should bootstrap table if empty TABLE is given', () => {\n    $wrapper.width(200).height(200);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      renderAllRows: true\n    });\n    wt.draw();\n\n    expect($table.find('td').length).toBe(400);\n  });\n\n  it('should bootstrap column headers if THEAD is given', () => {\n    $table.remove();\n    $table = $('<table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead></table>');\n    $table.appendTo('body');\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }]\n    });\n    wt.draw();\n    expect($table.find('thead th').length).toBe(5); // include corner TH\n    expect($table.find('tbody tr:first th').length).toBe(1);\n    expect($table.find('tbody tr:first td').length).toBe(4);\n  });\n\n  it('should figure out how many columns to display if width param given', () => {\n    $wrapper.width(100);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n    expect($table.find('tbody tr:first td').length).toBe(2);\n  });\n\n  it('should not render table that is removed from DOM', () => {\n    $wrapper.remove();\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n    expect(wt.drawn).toBe(false);\n    expect(wt.drawInterrupted).toBe(true);\n  });\n\n  it('should not render table that is `display: none`', () => {\n    const $div = $('<div style=\"display: none\"></div>').appendTo('body');\n    $div.append($table);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n    expect(wt.drawn).toBe(false);\n    expect(wt.drawInterrupted).toBe(true);\n\n    $div.remove();\n  });\n\n  it('should render empty table (limited height)', () => {\n    createDataArray(0, 5);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    expect(() => {\n      wt.draw(); // second render was giving \"Cannot read property 'firstChild' of null\" sometimes\n    }).not.toThrow();\n  });\n\n  it('should render empty table (unlimited height)', () => {\n    createDataArray(0, 5);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    expect(() => {\n      wt.draw(); // second render was giving \"Cannot read property 'firstChild' of null\" sometimes\n    }).not.toThrow();\n  });\n\n  it('should render empty then filled table (limited height)', () => {\n    createDataArray(0, 5);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n    createDataArray(1, 5);\n\n    expect(() => {\n      wt.draw(); // second render was giving \"Cannot read property 'firstChild' of null\" sometimes\n    }).not.toThrow();\n  });\n\n  it('should render empty then filled table (unlimited height)', () => {\n    createDataArray(0, 5);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n    createDataArray(1, 5);\n\n    expect(() => {\n      wt.draw(); // second render was giving \"Cannot read property 'firstChild' of null\" sometimes\n    }).not.toThrow();\n  });\n\n  it('should render table with rows but no columns', () => {\n    createDataArray(5, 0);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    expect($table.find('tbody tr').length).toBe(5);\n    expect($table.find('tbody td').length).toBe(0);\n    expect($table.find('tbody col').length).toBe(0);\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/core.spec.js","describe('WalkontableEvent', () => {\n  let $table;\n  const debug = false;\n\n  beforeEach(() => {\n    $table = $('<table></table>'); // create a table that is not attached to document\n    $table.appendTo('body');\n    createDataArray();\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n  });\n\n  it('should call `onCellMouseDown` callback', () => {\n    let myCoords = null;\n    let myTD = null;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      onCellMouseDown(event, coords, TD) {\n        myCoords = coords;\n        myTD = TD;\n      }\n    });\n\n    wt.draw();\n\n    const $td = $table.find('tbody tr:eq(1) td:eq(1)');\n\n    $td.simulate('mousedown');\n\n    expect(myCoords).toEqual(new Walkontable.CellCoords(1, 1));\n    expect(myTD).toEqual($td[0]);\n  });\n\n  it('should call `onCellContextMenu` callback', () => {\n    let myCoords = null;\n    let myTD = null;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      onCellContextMenu(event, coords, TD) {\n        myCoords = coords;\n        myTD = TD;\n      }\n    });\n\n    wt.draw();\n\n    const $td = $table.find('tbody tr:eq(1) td:eq(1)');\n\n    $td.simulate('contextmenu');\n\n    expect(myCoords).toEqual(new Walkontable.CellCoords(1, 1));\n    expect(myTD).toEqual($td[0]);\n  });\n\n  it('should call `onCellMouseOver` callback', () => {\n    let myCoords = null;\n    let myTD = null;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      onCellMouseOver(event, coords, TD) {\n        myCoords = coords;\n        myTD = TD;\n      }\n    });\n\n    wt.draw();\n\n    const $td = $table.find('tbody tr:eq(1) td:eq(1)');\n\n    $td.simulate('mouseover');\n\n    expect(myCoords).toEqual(new Walkontable.CellCoords(1, 1));\n    expect(myTD).toEqual($td[0]);\n  });\n\n  it('should call `onCellMouseOver` callback with correctly passed TD element when cell contains another table', () => {\n    const fn = jasmine.createSpy();\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: [['<table style=\"width: 50px;\"><tr><td class=\"test\">TEST</td></tr></table>']],\n      totalRows: 1,\n      totalColumns: 1,\n      onCellMouseOver: fn,\n      cellRenderer(row, column, TD) {\n        TD.innerHTML = wt.wtSettings.getSetting('data', row, column);\n      },\n    });\n\n    wt.draw();\n\n    const outerTD = $table.find('tbody td:not(td.test)');\n    const innerTD = $table.find('tbody td.test');\n\n    innerTD.simulate('mouseover');\n\n    expect(fn.calls.argsFor(0)[2]).toBe(outerTD[0]);\n  });\n\n  it('should call `onCellMouseOut` callback', () => {\n    let myCoords = null;\n    let myTD = null;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      onCellMouseOut(event, coords, TD) {\n        myCoords = coords;\n        myTD = TD;\n      }\n    });\n\n    wt.draw();\n\n    const $td = $table.find('tbody tr:eq(1) td:eq(1)');\n\n    $td.simulate('mouseover')\n      .simulate('mouseout');\n\n    expect(myCoords).toEqual(new Walkontable.CellCoords(1, 1));\n    expect(myTD).toEqual($td[0]);\n  });\n\n  it('should call `onCellMouseOut` callback with correctly passed TD element when cell contains another table', () => {\n    const fn = jasmine.createSpy();\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: [['<table style=\"width: 50px;\"><tr><td class=\"test\">TEST</td></tr></table>']],\n      totalRows: 1,\n      totalColumns: 1,\n      onCellMouseOut: fn,\n      cellRenderer(row, column, TD) {\n        TD.innerHTML = wt.wtSettings.getSetting('data', row, column);\n      },\n    });\n\n    wt.draw();\n\n    const outerTD = $table.find('tbody td:not(td.test)');\n\n    $table.find('tbody td.test')\n      .simulate('mouseover')\n      .simulate('mouseout');\n\n    expect(fn.calls.argsFor(0)[2]).toBe(outerTD[0]);\n  });\n\n  it('should call `onCellDblClick` callback', () => {\n    let myCoords = null;\n    let myTD = null;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      onCellDblClick(event, coords, TD) {\n        myCoords = coords;\n        myTD = TD;\n      }\n    });\n\n    wt.draw();\n\n    const $td = $table.find('tbody tr:eq(1) td:eq(1)');\n\n    $td.simulate('mousedown')\n      .simulate('mouseup')\n      .simulate('mousedown')\n      .simulate('mouseup');\n\n    expect(myCoords).toEqual(new Walkontable.CellCoords(1, 1));\n    expect(myTD).toEqual($td[0]);\n  });\n\n  it('should call `onCellDblClick` callback, even when it is set only after first click', () => {\n    let myCoords = null;\n    let myTD = null;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n\n    wt.draw();\n\n    const $td = $table.find('tbody tr:eq(1) td:eq(1)');\n\n    $td.simulate('mousedown')\n      .simulate('mouseup')\n      .simulate('mousedown');\n    wt.update('onCellDblClick', (event, coords, TD) => {\n      myCoords = coords;\n      myTD = TD;\n    });\n    $td.simulate('mouseup');\n\n    expect(myCoords).toEqual(new Walkontable.CellCoords(1, 1));\n    expect(myTD).toEqual($td[0]);\n  });\n\n  it('should call `onCellMouseDown` callback when clicked on TH', () => {\n    let called = false;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }],\n      onCellMouseDown() {\n        called = true;\n      }\n    });\n\n    wt.draw();\n\n    $table.find('th:first').simulate('mousedown');\n\n    expect(called).toEqual(true);\n  });\n\n  it('should not call `onCellMouseDown` callback when clicked on the focusable element (column headers)', () => {\n    const opt = ['Maserati', 'Mazda', 'Mercedes', 'Mini', 'Mitsubishi'].map(value => `<option value=\"${value}\">${value}</option>`).join('');\n    let called = false;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = `#${col}<select>${opt}</select>`;\n      }],\n      onCellMouseDown() {\n        called = true;\n      }\n    });\n\n    wt.draw();\n\n    $table.find('th:first select')\n      .focus()\n      .simulate('mousedown');\n\n    expect(called).toBe(false);\n  });\n\n  it('should not call `onCellMouseDown` callback when clicked on the focusable element (cell renderer)', () => {\n    const opt = ['Maserati', 'Mazda', 'Mercedes', 'Mini', 'Mitsubishi'].map(value => `<option value=\"${value}\">${value}</option>`).join('');\n    let called = false;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      cellRenderer(row, column, TD) {\n        TD.innerHTML = `<select>${opt}</select>`;\n      },\n      onCellMouseDown() {\n        called = true;\n      }\n    });\n\n    wt.draw();\n\n    $table.find('td:first select')\n      .focus()\n      .simulate('mousedown');\n\n    expect(called).toBe(false);\n  });\n\n  it('should call `onCellMouseOver` callback when clicked on TH', () => {\n    let called = false;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }],\n      onCellMouseOver(event, coords) {\n        called = coords;\n      }\n    });\n\n    wt.draw();\n\n    $table.find('th:first').simulate('mouseover');\n\n    expect(called.row).toEqual(-1);\n    expect(called.col).toEqual(0);\n  });\n\n  it('should call `onCellDblClick` callback when clicked on TH', () => {\n    let called = false;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }],\n      onCellDblClick() {\n        called = true;\n      }\n    });\n\n    wt.draw();\n\n    $table.find('th:first')\n      .simulate('mousedown')\n      .simulate('mouseup')\n      .simulate('mousedown')\n      .simulate('mouseup');\n\n    expect(called).toEqual(true);\n  });\n\n  it('should not call `onCellDblClick` callback when right-clicked', () => {\n    let called = false;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      onCellDblClick() {\n        called = true;\n      }\n    });\n\n    wt.draw();\n\n    const options = {\n      button: 2\n    };\n\n    $table.find('tbody tr:first td:first')\n      .simulate('mousedown', options)\n      .simulate('mouseup', options)\n      .simulate('mousedown', options)\n      .simulate('mouseup', options);\n\n    expect(called).toEqual(false);\n  });\n\n  it('should not call `onCellDblClick` when first mouse up came from mouse drag', () => {\n    let called = false;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      onCellDblClick() {\n        called = true;\n      }\n    });\n\n    wt.draw();\n\n    $table.find('tbody tr:first td:eq(1)').simulate('mousedown');\n    $table.find('tbody tr:first td:first')\n      .simulate('mouseup')\n      .simulate('mousedown')\n      .simulate('mouseup');\n\n    expect(called).toEqual(false);\n  });\n\n  it('border click should call `onCellMouseDown` callback', () => {\n    let myCoords = null;\n    let myTD = null;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          className: 'current',\n          border: {\n            width: 1,\n            color: 'red',\n            style: 'solid'\n          }\n        })\n      }),\n      onCellMouseDown(event, coords, TD) {\n        myCoords = coords;\n        myTD = TD;\n      }\n    });\n\n    wt.selections.getCell().add(new Walkontable.CellCoords(1, 1));\n    wt.draw();\n\n    const $td = $table.find('tbody tr:eq(1) td:eq(1)');\n\n    $table.parents('.wtHolder')\n      .find('.current:first')\n      .simulate('mousedown');\n\n    expect(myCoords).toEqual(new Walkontable.CellCoords(1, 1));\n    expect(myTD).toEqual($td[0]);\n  });\n\n  it('border click should call `onCellDblClick` callback', () => {\n    let myCoords = null;\n    let myTD = null;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          className: 'current',\n          border: {\n            width: 1,\n            color: 'red',\n            style: 'solid'\n          }\n        })\n      }),\n      onCellDblClick(event, coords, TD) {\n        myCoords = coords;\n        myTD = TD;\n      }\n    });\n\n    wt.selections.getCell().add(new Walkontable.CellCoords(1, 1));\n    wt.draw();\n\n    const $td = $table.find('tbody tr:eq(1) td:eq(1)');\n\n    $table.parents('.wtHolder')\n      .find('.current:first')\n      .simulate('mousedown')\n      .simulate('mouseup')\n      .simulate('mousedown')\n      .simulate('mouseup');\n\n    expect(myCoords).toEqual(new Walkontable.CellCoords(1, 1));\n    expect(myTD).toEqual($td[0]);\n  });\n\n  // corner\n  it('should call `onCellCornerMouseDown` callback', () => {\n    let clicked = false;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          className: 'current',\n          border: {\n            width: 1,\n            color: 'red',\n            style: 'solid'\n          }\n        })\n      }),\n      onCellCornerMouseDown() {\n        clicked = true;\n      }\n    });\n\n    wt.selections.getCell().add(new Walkontable.CellCoords(10, 2));\n    wt.draw();\n\n    $table.parents('.wtHolder')\n      .find('.current.corner')\n      .simulate('mousedown');\n\n    expect(clicked).toEqual(true);\n  });\n\n  it('should call `onCellCornerDblClick` callback, even when it is set only after first click', () => {\n    let clicked = false;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          className: 'current',\n          border: {\n            width: 1,\n            color: 'red',\n            style: 'solid'\n          }\n        })\n      }),\n    });\n\n    wt.selections.getCell().add(new Walkontable.CellCoords(10, 2));\n    wt.draw();\n\n    const $td = $table.parents('.wtHolder').find('.current.corner');\n\n    $td.simulate('mousedown')\n      .simulate('mouseup')\n      .simulate('mousedown');\n    wt.update('onCellCornerDblClick', () => {\n      clicked = true;\n    });\n    $td.simulate('mouseup');\n\n    expect(clicked).toEqual(true);\n  });\n\n  it('should call `onDraw` callback after render', () => {\n    let count = 0;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      onDraw() {\n        count += 1;\n      }\n    });\n\n    wt.draw();\n\n    expect(count).toEqual(1);\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/event.spec.js","describe('Walkontable.ColumnFilter', () => {\n  describe('offsettedTH', () => {\n    it('should do nothing if row header is not visible', () => {\n      const filter = new Walkontable.ColumnFilter();\n      filter.countTH = 0;\n      expect(filter.offsettedTH(1)).toEqual(1);\n    });\n\n    it('should decrease n by 1 if row header is visible', () => {\n      const filter = new Walkontable.ColumnFilter();\n      filter.countTH = 1;\n      expect(filter.offsettedTH(1)).toEqual(0);\n    });\n  });\n\n  describe('unOffsettedTH', () => {\n    it('should do nothing if row header is not visible', () => {\n      const filter = new Walkontable.ColumnFilter();\n      filter.countTH = 0;\n      expect(filter.unOffsettedTH(1)).toEqual(1);\n    });\n\n    it('should increase n by 1 if row header is visible', () => {\n      const filter = new Walkontable.ColumnFilter();\n      filter.countTH = 1;\n      expect(filter.unOffsettedTH(0)).toEqual(1);\n    });\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/filter/column.spec.js","describe('Walkontable.RowFilter', () => {\n\n  describe('offsetted', () => {\n    it('should return n, when offset == 0 && n == 0', () => {\n      const filter = new Walkontable.RowFilter();\n      filter.offset = 0;\n      filter.total = 100;\n      expect(filter.offsetted(0)).toEqual(0);\n    });\n\n    it('should return n, when offset == 0 && n == 5', () => {\n      const filter = new Walkontable.RowFilter();\n      filter.offset = 0;\n      filter.total = 100;\n      expect(filter.offsetted(5)).toEqual(5);\n    });\n\n    it('should return n + 1, when offset == 1 && n == 0', () => {\n      const filter = new Walkontable.RowFilter();\n      filter.offset = 1;\n      filter.total = 100;\n      expect(filter.offsetted(0)).toEqual(1);\n    });\n\n    it('should return n + 5, when offset == 5 && n == 0', () => {\n      const filter = new Walkontable.RowFilter();\n      filter.offset = 5;\n      filter.total = 100;\n      expect(filter.offsetted(0)).toEqual(5);\n    });\n  });\n\n  describe('unOffsetted', () => {\n    it('should return n, when offset == 0 && n == 0', () => {\n      const filter = new Walkontable.RowFilter();\n      filter.offset = 0;\n      filter.total = 100;\n      expect(filter.unOffsetted(0)).toEqual(0);\n    });\n\n    it('should return n, when offset == 0 && n == 5', () => {\n      const filter = new Walkontable.RowFilter();\n      filter.offset = 0;\n      filter.total = 100;\n      expect(filter.unOffsetted(5)).toEqual(5);\n    });\n\n    it('should return n - 1, when offset == 1 && n == 0', () => {\n      const filter = new Walkontable.RowFilter();\n      filter.offset = 1;\n      filter.total = 100;\n      expect(filter.unOffsetted(1)).toEqual(0);\n    });\n\n    it('should return n - 5, when offset == 5 && n == 0', () => {\n      const filter = new Walkontable.RowFilter();\n      filter.offset = 5;\n      filter.total = 100;\n      expect(filter.unOffsetted(5)).toEqual(0);\n    });\n  });\n\n  describe('renderedToSource', () => {\n    it('should translate visible column to source', () => {\n      const filter = new Walkontable.RowFilter();\n      filter.fixedCount = 1; // only cell index 0 falls into this\n      filter.offset = 4;\n      expect(filter.renderedToSource(0)).toEqual(4);\n      expect(filter.renderedToSource(1)).toEqual(5);\n      expect(filter.renderedToSource(2)).toEqual(6);\n    });\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/filter/row.spec.js","describe('WalkontableScroll', () => {\n  const debug = false;\n  let $container;\n  let $wrapper;\n  let $table;\n\n  beforeEach(() => {\n    $wrapper = $('<div></div>').css({ overflow: 'hidden' });\n    $container = $('<div></div>');\n    $table = $('<table></table>'); // create a table that is not attached to document\n    $wrapper.append($container);\n    $container.append($table);\n    $wrapper.appendTo('body');\n    createDataArray(100, 4);\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n\n    $wrapper.remove();\n  });\n\n  describe('scroll', () => {\n    it('should scroll to last column when rowHeaders is not in use', () => {\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n      wt.scrollViewportHorizontally(getTotalColumns() - 1);\n      wt.draw();\n\n      expect($table.find('tbody tr:eq(0) td:last')[0].innerHTML).toBe('c');\n    });\n\n    it('should scroll to last column when rowHeaders is in use', () => {\n      function plusOne(i) {\n        return i + 1;\n      }\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        columnHeaders: [function(col, TH) {\n          TH.innerHTML = plusOne(col);\n        }],\n        rowHeaders: [function(row, TH) {\n          TH.innerHTML = plusOne(row);\n        }]\n      });\n\n      wt.draw();\n      wt.scrollViewportHorizontally(getTotalColumns() - 1);\n      wt.draw();\n\n      expect($table.find('tbody tr:eq(0) td:last')[0].innerHTML).toBe('c');\n    });\n\n    it('scroll not scroll the viewport if all rows are visible', () => {\n      spec().data.splice(5);\n\n      $wrapper.height(201).width(100);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n\n      expect(wt.wtTable.getVisibleRowsCount()).toEqual(5);\n\n      wt.scrollViewportVertically(getTotalRows() - 1);\n      wt.draw();\n\n      expect(wt.wtTable.getCoords($table.find('tbody tr:eq(0) td:eq(0)')[0])).toEqual(new Walkontable.CellCoords(0, 0));\n    });\n\n    it('scroll horizontal should take totalColumns if it is smaller than width', () => {\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n      wt.scrollViewportHorizontally(getTotalColumns() - 1);\n      wt.draw();\n\n      expect(wt.wtTable.getCoords($table.find('tbody tr:eq(0) td:eq(0)')[0])).toEqual(new Walkontable.CellCoords(0, 0));\n    });\n\n    it('scroll vertical should return `false` if given number smaller than 0', () => {\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n\n      expect(wt.scrollViewportVertically(-1)).toBe(false);\n    });\n\n    it('scroll vertical should return `false` if given number bigger than totalRows', () => {\n      spec().data.splice(20, spec().data.length - 20);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n\n      expect(wt.scrollViewportVertically(999)).toBe(false);\n    });\n\n    it('scroll horizontal should return `false` if given number smaller than 0', () => {\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n\n      expect(wt.scrollViewportHorizontally(-1)).toBe(false);\n    });\n\n    it('scroll horizontal should return `false` if given number bigger than totalRows', () => {\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n\n      expect(wt.scrollViewportHorizontally(999)).toBe(false);\n    });\n\n    it('scroll viewport to a cell that is visible should do nothing', () => {\n      $wrapper.height(201).width(120);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n\n      const tmp = wt.getViewport();\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 1));\n      wt.draw();\n\n      expect(wt.getViewport()).toEqual(tmp);\n    });\n\n    it('scroll viewport to a cell on far right should make it visible on right edge', () => {\n      $wrapper.width(125).height(201);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n\n      const height = $wrapper[0].clientHeight;\n      const visibleRowCount = Math.floor(height / 23);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 2));\n      wt.draw();\n\n      expect(wt.getViewport()).toEqual([0, 1, visibleRowCount - 1, 2]);\n    });\n\n    it('scroll viewport to a cell on far left should make it visible on left edge', () => {\n      $wrapper.width(100).height(201);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n\n      const height = $wrapper[0].clientHeight;\n      const visibleRowCount = Math.floor(height / 23);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 3));\n      wt.draw();\n      expect(wt.getViewport()).toEqual([0, 3, visibleRowCount - 1, 3]);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 1));\n      wt.draw();\n      expect(wt.getViewport()).toEqual([0, 1, visibleRowCount - 1, 1]);\n    });\n\n    it('scroll viewport to a cell on far left should make it visible on left edge (with row header)', () => {\n      $wrapper.width(140).height(201);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        rowHeaders: [function(row, TH) {\n          TH.innerHTML = row + 1;\n        }]\n      });\n\n      wt.draw();\n\n      const height = $wrapper[0].clientHeight;\n      const visibleRowCount = Math.floor(height / 23);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 3));\n      wt.draw();\n      expect(wt.getViewport()).toEqual([0, 3, visibleRowCount - 1, 3]);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 1));\n      wt.draw();\n      expect(wt.wtTable.getFirstVisibleColumn()).toEqual(1);\n    });\n\n    it('scroll viewport to a cell on far right should make it visible on right edge (with row header)', () => {\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        rowHeaders: [function(row, TH) {\n          TH.innerHTML = row + 1;\n        }]\n      });\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(0, 2));\n      wt.draw();\n\n      expect(wt.wtTable.getCoords($table.find('tbody tr:first td:last')[0])).toEqual(new Walkontable.CellCoords(0, 3));\n    });\n\n    it('scroll viewport to a cell on far bottom should make it visible on bottom edge', () => {\n      $wrapper.width(125).height(201);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(12, 0));\n      wt.draw();\n\n      expect(wt.getViewport()[0]).toBeAroundValue(5);\n      expect(wt.getViewport()[1]).toBeAroundValue(0);\n      expect(wt.getViewport()[2]).toBeAroundValue(12);\n      expect(wt.getViewport()[3]).toBeAroundValue(1);\n    });\n\n    it('scroll viewport to a cell on far top should make it visible on top edge', () => {\n      $wrapper.width(100).height(201);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(20, 0));\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(12, 0));\n      wt.draw();\n\n      expect(wt.wtTable.getCoords($table.find('tbody tr:first td:first')[0])).toEqual(new Walkontable.CellCoords(12, 0));\n    });\n\n    it('scroll viewport to a cell that does not exist (vertically) should return `false`', () => {\n      spec().data.splice(20, spec().data.length - 20);\n\n      $wrapper.width(100).height(201);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n\n      expect(wt.scrollViewport(new Walkontable.CellCoords(40, 0))).toBe(false);\n    });\n\n    it('scroll viewport to a cell that does not exist (horizontally) should return `false`', () => {\n      $wrapper.width(100).height(201);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n\n      expect(wt.scrollViewport(new Walkontable.CellCoords(0, 40))).toBe(false);\n    });\n\n    it('remove row from the last scroll page should scroll viewport a row up if needed', () => {\n      $wrapper.width(100).height(210);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(getTotalRows() - 1, 0));\n      wt.draw();\n\n      const originalViewportStartRow = wt.getViewport()[0];\n\n      spec().data.splice(getTotalRows() - 4, 1); // remove row at index 96\n      wt.draw();\n\n      expect(originalViewportStartRow - 1).toEqual(wt.getViewport()[0]);\n    });\n\n    it('should scroll to last row if smaller data source is loaded that does not have currently displayed row', () => {\n      $wrapper.width(100).height(260);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n      wt.scrollViewportVertically(50);\n      wt.draw();\n      spec().data.splice(30, spec().data.length - 30);\n      wt.draw();\n\n      expect($table.find('tbody tr').length).toBeGreaterThan(9);\n    });\n\n    it('should scroll to last column if smaller data source is loaded that does not have currently displayed column', () => {\n      createDataArray(20, 100);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n      wt.scrollViewportHorizontally(50);\n      wt.draw();\n      createDataArray(100, 30);\n      wt.draw();\n\n      expect($table.find('tbody tr:first td').length).toBeGreaterThan(3);\n    });\n\n    it('should scroll to last row with very high rows', function() {\n      createDataArray(20, 100);\n\n      for (let i = 0, ilen = this.data.length; i < ilen; i++) {\n        this.data[i][0] += '\\n this \\nis \\na \\nmultiline \\ncell';\n      }\n\n      $wrapper.width(260).height(201);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n      wt.scrollViewportVertically(getTotalRows() - 1);\n      wt.draw();\n\n      expect($table.find('tbody tr:last td:first')[0]).toBe(wt.wtTable.getCell(new Walkontable.CellCoords(this.data.length - 1, 0))); // last rendered row should be last data row\n    });\n\n    xit('should scroll to last row with very high rows (respecting fixedRows)', () => {\n      createDataArray(20, 100);\n\n      for (let i = 0, ilen = spec().data.length; i < ilen; i++) {\n        spec().data[i][0] += '\\n this \\nis \\na \\nmultiline \\ncell';\n      }\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        fixedRowsTop: 2\n      });\n\n      wt.draw();\n      wt.scrollViewportVertically(2000);\n      wt.draw();\n\n      expect($table.find('tbody tr:eq(0) td:first')[0]).toBe(wt.wtTable.getCell(new Walkontable.CellCoords(0, 0))); // first rendered row should fixed row 0\n      expect($table.find('tbody tr:eq(1) td:first')[0]).toBe(wt.wtTable.getCell(new Walkontable.CellCoords(1, 0))); // second rendered row should fixed row 1\n      expect($table.find('tbody tr:eq(2) td:first')[0]).toBe(wt.wtTable.getCell(new Walkontable.CellCoords(2, 0))); // third rendered row should fixed row 1\n      expect($table.find('tbody tr:last td:first')[0]).toBe(wt.wtTable.getCell(new Walkontable.CellCoords(spec().data.length - 1, 0))); // last rendered row should be last data row\n    });\n\n    it('should scroll to last column with very wide cells', () => {\n      createDataArray(20, 100);\n      $wrapper.width(260).height(201);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n      wt.scrollViewportHorizontally(50);\n      wt.draw();\n      createDataArray(100, 30);\n      wt.draw();\n\n      expect($table.find('tbody tr:first td').length).toBeGreaterThan(3);\n    });\n\n    it('should scroll the desired cell to the bottom edge even if it\\'s located in a fixed column', (done) => {\n      createDataArray(20, 100);\n      $wrapper.width(260).height(201);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        fixedColumnsLeft: 2\n      });\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(8, 1));\n      wt.draw();\n\n      setTimeout(() => {\n        expect(wt.wtTable.getLastVisibleRow()).toBe(8);\n        done();\n      }, 20);\n    });\n\n    it('should update the scroll position of overlays only once, when scrolling the master table', (done) => {\n      createDataArray(100, 100);\n      $wrapper.width(260).height(201);\n\n      const topOverlayCallback = jasmine.createSpy('topOverlayCallback');\n      const leftOverlayCallback = jasmine.createSpy('leftOverlayCallback');\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        fixedColumnsLeft: 2,\n        fixedRowsTop: 2\n      });\n      const masterHolder = wt.wtTable.holder;\n      const leftOverlayHolder = wt.wtOverlays.leftOverlay.clone.wtTable.holder;\n      const topOverlayHolder = wt.wtOverlays.topOverlay.clone.wtTable.holder;\n\n      topOverlayHolder.addEventListener('scroll', topOverlayCallback);\n      leftOverlayHolder.addEventListener('scroll', leftOverlayCallback);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(50, 50));\n      wt.draw();\n\n      setTimeout(() => {\n        expect(topOverlayCallback.calls.count()).toEqual(1);\n        expect(leftOverlayCallback.calls.count()).toEqual(1);\n\n        expect(topOverlayHolder.scrollLeft).toEqual(masterHolder.scrollLeft);\n        expect(leftOverlayHolder.scrollTop).toEqual(masterHolder.scrollTop);\n\n        topOverlayHolder.removeEventListener('scroll', topOverlayCallback);\n        leftOverlayHolder.removeEventListener('scroll', leftOverlayCallback);\n        done();\n      }, 20);\n    });\n\n    it('should call onScrollVertically hook, if scrollTop was changed', (done) => {\n      createDataArray(100, 100);\n      $wrapper.width(260).height(201);\n\n      const scrollHorizontally = jasmine.createSpy('scrollHorizontal');\n      const scrollVertically = jasmine.createSpy('scrollVertically');\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        fixedColumnsLeft: 2,\n        fixedRowsTop: 2,\n        onScrollVertically: scrollVertically,\n        onScrollHorizontally: scrollHorizontally,\n      });\n\n      wt.draw();\n      wt.wtTable.holder.scrollTop = 400;\n\n      wt.draw();\n\n      setTimeout(() => {\n        expect(scrollVertically.calls.count()).toEqual(1);\n        expect(scrollHorizontally.calls.count()).toEqual(0);\n        done();\n      }, 50);\n    });\n\n    it('should call onScrollHorizontally hook, if scrollLeft was changed', (done) => {\n      createDataArray(100, 100);\n      $wrapper.width(260).height(201);\n\n      const scrollHorizontally = jasmine.createSpy('scrollHorizontal');\n      const scrollVertically = jasmine.createSpy('scrollVertically');\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        fixedColumnsLeft: 2,\n        fixedRowsTop: 2,\n        onScrollVertically: scrollVertically,\n        onScrollHorizontally: scrollHorizontally,\n      });\n\n      wt.draw();\n      wt.wtTable.holder.scrollLeft = 400;\n\n      wt.draw();\n\n      setTimeout(() => {\n        expect(scrollVertically.calls.count()).toEqual(0);\n        expect(scrollHorizontally.calls.count()).toEqual(1);\n\n        done();\n      }, 50);\n    });\n\n    // Commented due to PhantomJS WheelEvent problem.\n    // Throws an error: TypeError: '[object WheelEventConstructor]' is not a constructor\n    xit('should scroll the table when the `wheel` event is triggered on the corner overlay', (done) => {\n      createDataArray(100, 100);\n      $wrapper.width(260).height(201);\n\n      const masterCallback = jasmine.createSpy('masterCallback');\n      const topCallback = jasmine.createSpy('topCallback');\n      const leftCallback = jasmine.createSpy('leftCallback');\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        fixedColumnsLeft: 2,\n        fixedRowsTop: 2\n      });\n\n      wt.draw();\n\n      const topLeftCornerOverlayHolder = wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.holder;\n      const topHolder = wt.wtOverlays.topOverlay.clone.wtTable.holder;\n      const leftHolder = wt.wtOverlays.leftOverlay.clone.wtTable.holder;\n      const masterHolder = wt.wtTable.holder;\n\n      masterHolder.addEventListener('scroll', masterCallback);\n      topHolder.addEventListener('scroll', topCallback);\n      leftHolder.addEventListener('scroll', leftCallback);\n\n      let wheelEvent = new WheelEvent('wheel', {\n        deltaX: 400\n      });\n\n      topLeftCornerOverlayHolder.dispatchEvent(wheelEvent);\n\n      wt.draw();\n\n      setTimeout(() => {\n        expect(masterCallback.callCount).toEqual(1);\n        expect(topCallback.callCount).toEqual(1);\n        expect(leftCallback.callCount).toEqual(0);\n\n        wheelEvent = new WheelEvent('wheel', {\n          deltaY: 400\n        });\n\n        topLeftCornerOverlayHolder.dispatchEvent(wheelEvent);\n        wt.draw();\n      }, 20);\n\n      setTimeout(() => {\n        expect(masterCallback.callCount).toEqual(2);\n        expect(topCallback.callCount).toEqual(1);\n        expect(leftCallback.callCount).toEqual(1);\n        done();\n      }, 40);\n    });\n  });\n\n  describe('scrollViewport - horizontally', () => {\n    beforeEach(() => {\n      $wrapper.width(201).height(201);\n    });\n\n    it('should scroll to last column on the right', () => {\n      spec().data = createSpreadsheetData(10, 10);\n\n      $wrapper.width(201).height(201);\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        columnWidth: 50\n      });\n\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(2);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 9));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(9);\n    });\n\n    it('should not scroll back to a column that is in viewport', () => {\n      spec().data = createSpreadsheetData(10, 10);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        columnWidth: 50\n      });\n\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(2);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 9));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(9);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 9));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(9); // nothing changed\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 8));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(9); // nothing changed\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 7));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(9); // nothing changed\n    });\n\n    it('should scroll back to a column that is before viewport', () => {\n      spec().data = createSpreadsheetData(10, 10);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        columnWidth: 50\n      });\n\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(2);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 9));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(9);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(0, 3));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(5);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(0, 4));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(5);// nothing changed\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 9));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(9);\n    });\n\n    it('should scroll to a column that is after viewport', () => {\n      spec().data = createSpreadsheetData(10, 10);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        columnWidth: 50\n      });\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(0, 2));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(2);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(0, 4));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(4);\n    });\n\n    it('should scroll to a wide column that is after viewport', () => {\n      spec().data = createSpreadsheetData(10, 10);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        columnWidth(col) {\n          if (col === 3) {\n            return 100;\n          }\n\n          return 50;\n        }\n      });\n\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(2);\n      expect(wt.wtTable.getFirstVisibleColumn()).toEqual(0);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 3));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(3);\n      expect(wt.wtTable.getFirstVisibleColumn()).toEqual(2);\n    });\n\n    xit('should scroll to a very wide column that is after viewport', () => {\n      spec().data = createSpreadsheetData(10, 10);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        columnWidth(col) {\n          if (col === 3) {\n            return 300;\n          }\n\n          return 50;\n        }\n      });\n\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(3);\n      expect(wt.wtTable.getFirstVisibleColumn()).toEqual(0);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 3)).draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(3);\n      expect(wt.wtTable.getFirstVisibleColumn()).toEqual(3);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 2)).draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(3);\n      expect(wt.wtTable.getFirstVisibleColumn()).toEqual(2);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 3)).draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(3);\n      expect(wt.wtTable.getFirstVisibleColumn()).toEqual(3);\n\n      wt.scrollViewport(new Walkontable.CellCoords(0, 4)).draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(4);\n      expect(wt.wtTable.getFirstVisibleColumn()).toEqual(3);\n    });\n\n    xit('should scroll to a very wide column that is after viewport (with fixedColumnsLeft)', () => {\n      spec().data = createSpreadsheetData(1, 10);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        columnWidth(col) {\n          if (col === 3) {\n            return 300;\n          }\n\n          return 50;\n        },\n        fixedColumnsLeft: 2\n      });\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(0, 3));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(3);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(0, 2));\n      wt.draw();\n      expect(wt.wtTable.getFirstVisibleColumn()).toBeGreaterThan(2);\n      expect(wt.wtTable.getLastVisibleColumn()).toBeGreaterThan(2);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(0, 3));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(3);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(0, 4));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleColumn()).toEqual(4);\n    });\n  });\n\n  describe('scrollViewport - vertically', () => {\n    beforeEach(() => {\n      $wrapper.width(201).height(201);\n    });\n\n    xit('should scroll to a very high row that is after viewport', () => {\n      spec().data = createSpreadsheetData(20, 1);\n\n      const txt = 'Very very very very very very very very very very very very very very very very very long text.';\n      spec().data[4][0] = txt;\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n      expect(wt.wtTable.getFirstVisibleRow()).toEqual(0);\n\n      wt.scrollViewport(new Walkontable.CellCoords(4, 0));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleRow()).toEqual(4);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(5, 0));\n      wt.draw();\n      expect(wt.wtTable.getLastVisibleRow()).toEqual(5);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(4, 0));\n      wt.draw();\n      expect(wt.wtTable.getFirstVisibleRow()).toEqual(4);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(3, 0));\n      wt.draw();\n      expect(wt.wtTable.getFirstVisibleRow()).toEqual(3);\n    });\n\n    xit('should scroll to a very high row that is after viewport (at the end)', () => {\n      spec().data = createSpreadsheetData(20, 1);\n\n      const txt = 'Very very very very very very very very very very very very very very very very very long text.';\n      spec().data[19][0] = txt;\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(18, 0));\n      wt.draw();\n      expect($table.find('tbody tr').length).toBe(2);\n      expect($table.find('tbody tr:eq(0) td:eq(0)').html()).toBe('A18');\n      expect($table.find('tbody tr:eq(1) td:eq(0)').html()).toBe(txt);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(19, 0));\n      wt.draw();\n      expect($table.find('tbody tr').length).toBe(1);\n      expect($table.find('tbody tr:eq(0) td:eq(0)').html()).toBe(txt); // scrolled down\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(18, 0));\n      wt.draw();\n      expect($table.find('tbody tr').length).toBe(2);\n      expect($table.find('tbody tr:eq(0) td:eq(0)').html()).toBe('A18'); // scrolled up\n      expect($table.find('tbody tr:eq(1) td:eq(0)').html()).toBe(txt);\n\n      wt.draw();\n      wt.scrollViewport(new Walkontable.CellCoords(17, 0));\n      wt.draw();\n      expect($table.find('tbody tr').length).toBe(3);\n      expect($table.find('tbody tr:eq(0) td:eq(0)').html()).toBe('A17'); // scrolled up\n      expect($table.find('tbody tr:eq(1) td:eq(0)').html()).toBe('A18');\n      expect($table.find('tbody tr:eq(2) td:eq(0)').html()).toBe(txt);\n    });\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/scroll.spec.js","describe('WalkontableScrollbar', () => {\n  let $table;\n  let $container;\n  let $wrapper;\n  const debug = false;\n\n  beforeEach(() => {\n    $wrapper = $('<div></div>').css({ overflow: 'hidden' });\n    $container = $('<div></div>');\n    $table = $('<table></table>'); // create a table that is not attached to document\n    $wrapper.append($container);\n    $container.append($table);\n    $wrapper.appendTo('body');\n    createDataArray();\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n    $wrapper.remove();\n  });\n\n  it('should table in DIV.wtHolder that contains 2 scrollbars', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    expect($table.parents('.wtHolder').length).toEqual(1);\n  });\n\n  it('scrolling should have no effect when totalRows is smaller than height', function() {\n    this.data.splice(5, this.data.length - 5);\n\n    try {\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n      wt.draw();\n\n      wt.wtOverlays.topOverlay.onScroll(1);\n      expect(wt.getViewport()[0]).toEqual(0);\n      wt.wtOverlays.topOverlay.onScroll(-1);\n      expect(wt.getViewport()[0]).toEqual(0);\n    } catch (e) {\n      expect(e).toBeUndefined();\n    }\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/scrollbar.spec.js","describe('WalkontableScrollbarNative', () => {\n  let $table;\n  let $container;\n  let $wrapper;\n  const debug = false;\n\n  beforeEach(() => {\n    $wrapper = $('<div></div>').css({ overflow: 'hidden' });\n    $wrapper.width(100).height(200);\n    $container = $('<div></div>');\n    $table = $('<table></table>'); // create a table that is not attached to document\n    $wrapper.append($container);\n    $container.append($table);\n    $wrapper.appendTo('body');\n    createDataArray();\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n    $wrapper.remove();\n  });\n\n  it('initial render should be no different than the redraw (vertical)', () => {\n    createDataArray(100, 1);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    const tds = $table.find('td').length;\n    wt.draw();\n\n    expect($table.find('td').length).toEqual(tds);\n  });\n\n  it('initial render should be no different than the redraw (horizontal)', () => {\n    createDataArray(1, 50);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    const tds = $table.find('td').length;\n    wt.draw();\n\n    expect($table.find('td').length).toEqual(tds);\n  });\n\n  it('scrolling 50px down should render 2 more rows', () => {\n    createDataArray(20, 4);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    const lastRenderedRow = wt.wtTable.getLastRenderedRow();\n\n    $(wt.wtTable.holder).scrollTop(50);\n    wt.draw();\n\n    expect(wt.wtTable.getLastRenderedRow()).toEqual(lastRenderedRow + 2);\n  });\n\n  it('should recognize the scrollHandler properly, even if the \\'overflow\\' property is assigned in an external stylesheet', () => {\n    $wrapper.css({\n      overflow: ''\n    });\n    $wrapper.addClass('testOverflowHidden');\n\n    createDataArray(20, 4);\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    wt.wtOverlays.topOverlay.scrollTo(3);\n    expect($(wt.wtTable.holder).scrollTop()).toEqual(69);\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/scrollbarNative.spec.js","describe('Walkontable.Selection', () => {\n  let $table;\n  let $container;\n  let $wrapper;\n  const debug = false;\n\n  beforeEach(() => {\n    $wrapper = $('<div></div>').css({ overflow: 'hidden' });\n    $wrapper.width(100).height(200);\n    $container = $('<div></div>');\n    $table = $('<table></table>'); // create a table that is not attached to document\n    $wrapper.append($container);\n    $container.append($table);\n    $wrapper.appendTo('body');\n    createDataArray();\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n    $wrapper.remove();\n  });\n\n  it('should add/remove class to selection when cell is clicked', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController(),\n      onCellMouseDown(event, coords) {\n        wt.selections.getCell().clear();\n        wt.selections.getCell().add(coords);\n        wt.draw();\n      }\n    });\n    wt.draw();\n\n    const $td1 = $table.find('tbody td:eq(0)');\n    const $td2 = $table.find('tbody td:eq(1)');\n    $td1.simulate('mousedown');\n    expect($td1.hasClass('current')).toEqual(true);\n\n    $td2.simulate('mousedown');\n    expect($td1.hasClass('current')).toEqual(false);\n    expect($td2.hasClass('current')).toEqual(true);\n  });\n\n  it('should add class to selection on all overlays', function() {\n    $wrapper.width(300).height(300);\n\n    this.data = createSpreadsheetData(10, 10);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController(),\n      fixedColumnsLeft: 2,\n      fixedRowsTop: 2\n    });\n\n    wt.selections.createOrGetArea().add(new Walkontable.CellCoords(1, 1));\n    wt.selections.createOrGetArea().add(new Walkontable.CellCoords(1, 2));\n    wt.selections.createOrGetArea().add(new Walkontable.CellCoords(2, 1));\n    wt.selections.createOrGetArea().add(new Walkontable.CellCoords(2, 2));\n\n    wt.draw();\n\n    const tds = $wrapper.find('td:contains(B2), td:contains(B3), td:contains(C2), td:contains(C3)');\n    expect(tds.length).toBeGreaterThan(4);\n    for (let i = 0, ilen = tds.length; i < ilen; i++) {\n      expect(tds[i].className).toContain('area');\n    }\n  });\n\n  it('should not add class to selection until it is rerendered', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController(),\n    });\n    wt.draw();\n    wt.selections.getCell().add(new Walkontable.CellCoords(0, 0));\n\n    const $td1 = $table.find('tbody td:eq(0)');\n    expect($td1.hasClass('current')).toEqual(false);\n\n    wt.draw();\n    expect($td1.hasClass('current')).toEqual(true);\n  });\n\n  it('should add/remove border to selection when cell is clicked', (done) => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController(),\n      onCellMouseDown(event, coords) {\n        wt.selections.getCell().clear();\n        wt.selections.getCell().add(coords);\n        wt.draw();\n      }\n    });\n    wt.draw();\n\n    setTimeout(() => {\n      const $td1 = $table.find('tbody tr:eq(1) td:eq(0)');\n      const $td2 = $table.find('tbody tr:eq(2) td:eq(1)');\n      const $top = $(wt.selections.getCell().getBorder(wt).top); // cheat... get border for ht_master\n      $td1.simulate('mousedown');\n\n      const pos1 = $top.position();\n      expect(pos1.top).toBeGreaterThan(0);\n      expect(pos1.left).toBe(0);\n\n      $td2.simulate('mousedown');\n      const pos2 = $top.position();\n\n      expect(pos2.top).toBeGreaterThan(pos1.top);\n      expect(pos2.left).toBeGreaterThan(pos1.left);\n      done();\n    }, 1500);\n  });\n\n  it('should add a selection that is outside of the viewport', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController(),\n    });\n    wt.draw();\n\n    wt.selections.getCell().add([20, 0]);\n    expect(wt.wtTable.getCoords($table.find('tbody tr:first td:first')[0])).toEqual(new Walkontable.CellCoords(0, 0));\n  });\n\n  it('should not scroll the viewport after selection is cleared', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController(),\n    });\n\n    wt.draw();\n\n    wt.selections.getCell().add(new Walkontable.CellCoords(0, 0));\n    wt.draw();\n    expect(wt.wtTable.getFirstVisibleRow()).toEqual(0);\n\n    wt.scrollViewportVertically(17);\n    wt.draw();\n    expect(wt.wtTable.getFirstVisibleRow()).toEqual(10);\n    expect(wt.wtTable.getLastVisibleRow()).toBeAroundValue(17);\n\n    wt.selections.getCell().clear();\n    expect(wt.wtTable.getFirstVisibleRow()).toEqual(10);\n    expect(wt.wtTable.getLastVisibleRow()).toBeAroundValue(17);\n  });\n\n  it('should clear a selection that has more than one cell', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController(),\n    });\n    wt.draw();\n\n    wt.selections.getCell().add(new Walkontable.CellCoords(0, 0));\n    wt.selections.getCell().add(new Walkontable.CellCoords(0, 1));\n    wt.selections.getCell().clear();\n\n    expect(wt.selections.getCell().cellRange).toEqual(null);\n  });\n\n  it('should highlight cells in selected row & column', () => {\n    $wrapper.width(300);\n\n    const customSelection = new Walkontable.Selection({\n      highlightRowClassName: 'highlightRow',\n      highlightColumnClassName: 'highlightColumn'\n    });\n    customSelection.add(new Walkontable.CellCoords(0, 0));\n    customSelection.add(new Walkontable.CellCoords(0, 1));\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController({\n        custom: [customSelection],\n      }),\n    });\n    wt.draw();\n\n    expect($table.find('.highlightRow').length).toEqual(2);\n    expect($table.find('.highlightColumn').length).toEqual((wt.wtTable.getRenderedRowsCount() * 2) - 2);\n  });\n\n  it('should highlight cells in selected row & column, when same class is shared between 2 selection definitions', () => {\n    $wrapper.width(300);\n\n    const customSelection1 = new Walkontable.Selection({\n      highlightRowClassName: 'highlightRow',\n      highlightColumnClassName: 'highlightColumn'\n    });\n\n    customSelection1.add(new Walkontable.CellCoords(0, 0));\n\n    const customSelection2 = new Walkontable.Selection({\n      highlightRowClassName: 'highlightRow',\n      highlightColumnClassName: 'highlightColumn'\n    });\n\n    customSelection2.add(new Walkontable.CellCoords(0, 0));\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController({\n        custom: [customSelection1, customSelection2],\n      }),\n    });\n    wt.draw();\n\n    expect($table.find('.highlightRow').length).toEqual(3);\n    expect($table.find('.highlightColumn').length).toEqual(wt.wtTable.getRenderedRowsCount() - 1);\n  });\n\n  it('should remove highlight when selection is deselected', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          highlightRowClassName: 'highlightRow',\n          highlightColumnClassName: 'highlightColumn'\n        }),\n      }),\n    });\n    wt.draw();\n\n    wt.selections.getCell().add(new Walkontable.CellCoords(0, 0));\n    wt.selections.getCell().add(new Walkontable.CellCoords(0, 1));\n    wt.draw();\n\n    wt.selections.getCell().clear();\n    wt.draw();\n\n    expect($table.find('.highlightRow').length).toEqual(0);\n    expect($table.find('.highlightColumn').length).toEqual(0);\n  });\n\n  it('should add/remove appropriate class to the row/column headers of selected cells', () => {\n    $wrapper.width(300);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }],\n      columnHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }],\n      selections: createSelectionController({\n        current: new Walkontable.Selection({\n          highlightRowClassName: 'highlightRow',\n          highlightColumnClassName: 'highlightColumn'\n        }),\n      }),\n    });\n    wt.draw();\n\n    wt.selections.getCell().add(new Walkontable.CellCoords(1, 1));\n    wt.selections.getCell().add(new Walkontable.CellCoords(2, 2));\n    wt.draw();\n\n    // left side:\n    // -2 -> because one row is partially visible\n\n    // right side:\n    // *2 -> because there are 2 columns selected\n    // +2 -> because there are the headers\n    // -4 -> because 4 cells are selected = there are overlapping highlightRow class\n    expect($table.find('.highlightRow').length).toEqual((wt.wtViewport.columnsVisibleCalculator.count * 2) + 2 - 4);\n    expect($table.find('.highlightColumn').length - 2).toEqual((wt.wtViewport.rowsVisibleCalculator.count * 2) + 2 - 4);\n    expect($table.find('.highlightColumn').length).toEqual(14);\n    expect(getTableTopClone().find('.highlightColumn').length).toEqual(2);\n    expect(getTableTopClone().find('.highlightRow').length).toEqual(0);\n    expect(getTableLeftClone().find('.highlightColumn').length).toEqual(0);\n    expect(getTableLeftClone().find('.highlightRow').length).toEqual(2);\n\n    const $colHeaders = $table.find('thead tr:first-child th');\n    const $rowHeaders = $table.find('tbody tr th:first-child');\n\n    expect($colHeaders.eq(2).hasClass('highlightColumn')).toBe(true);\n    expect($colHeaders.eq(3).hasClass('highlightColumn')).toBe(true);\n\n    expect($rowHeaders.eq(1).hasClass('highlightRow')).toBe(true);\n    expect($rowHeaders.eq(2).hasClass('highlightRow')).toBe(true);\n\n    wt.selections.getCell().clear();\n    wt.draw();\n\n    expect($table.find('.highlightRow').length).toEqual(0);\n    expect($table.find('.highlightColumn').length).toEqual(0);\n    expect(getTableTopClone().find('.highlightColumn').length).toEqual(0);\n    expect(getTableTopClone().find('.highlightRow').length).toEqual(0);\n    expect(getTableLeftClone().find('.highlightColumn').length).toEqual(0);\n    expect(getTableLeftClone().find('.highlightRow').length).toEqual(0);\n  });\n\n  describe('replace', () => {\n    it('should replace range from property and return true', () => {\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        selections: createSelectionController(),\n      });\n      wt.selections.getCell().add(new Walkontable.CellCoords(1, 1));\n      wt.selections.getCell().add(new Walkontable.CellCoords(3, 3));\n      const result = wt.selections.getCell().replace(new Walkontable.CellCoords(3, 3), new Walkontable.CellCoords(4, 4));\n\n      expect(result).toBe(true);\n      expect(wt.selections.getCell().getCorners()).toEqual([1, 1, 4, 4]);\n    });\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/selection.spec.js","describe('columnHeaders option', () => {\n  let $table;\n  let $container;\n  let $wrapper;\n  const debug = false;\n\n  beforeEach(() => {\n    $wrapper = $('<div></div>').css({ overflow: 'hidden', position: 'relative' });\n    $wrapper.width(500).height(201);\n    $container = $('<div></div>');\n    $table = $('<table></table>'); // create a table that is not attached to document\n    $wrapper.append($container);\n    $container.append($table);\n    $wrapper.appendTo('body');\n    createDataArray();\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n    $wrapper.remove();\n  });\n\n  it('should not add class `htColumnHeaders` when column headers are disabled', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    expect($wrapper.hasClass('htColumnHeaders')).toBe(false);\n  });\n\n  it('should add class `htColumnHeaders` when column headers are enabled', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }]\n    });\n    wt.draw();\n\n    expect($wrapper.hasClass('htColumnHeaders')).toBe(true);\n  });\n\n  it('should create table with column headers', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }]\n    });\n    wt.draw();\n\n    expect($wrapper.find('.ht_clone_left colgroup col').length).toBe(0);\n    expect($wrapper.find('.ht_clone_left thead tr').length).toBe(1);\n    expect($wrapper.find('.ht_clone_left tbody tr').length).toBe(0);\n    expect($wrapper.find('.ht_clone_top colgroup col').length).toBe(4);\n    expect($wrapper.find('.ht_clone_top thead tr').length).toBe(1);\n    expect($wrapper.find('.ht_clone_top tbody tr').length).toBe(0);\n    expect($wrapper.find('.ht_master colgroup col').length).toBe(4);\n    expect($wrapper.find('.ht_master thead tr').length).toBe(1);\n    expect($wrapper.find('.ht_master tbody tr').length).toBe(9);\n  });\n\n  it('should create column headers with correct height when th has css `white-space: normal`', () => {\n    const style = $('<style>.handsontable thead th {white-space: normal;}</style>').appendTo('head');\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = 'Client State State';\n      }],\n      columnWidth: 80\n    });\n    wt.draw();\n\n    expect($wrapper.find('.ht_clone_top thead tr').height()).toBe(43);\n    style.remove();\n  });\n\n  it('should create column headers with correct height when th has css `white-space: pre-line` (default)', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = 'Client State State';\n      }],\n      columnWidth: 80\n    });\n    wt.draw();\n\n    expect($wrapper.find('.ht_clone_top thead tr').height()).toBe(23);\n  });\n\n  it('should generate column headers from function', () => {\n    const headers = ['Description', 2012, 2013, 2014];\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(column, TH) {\n        TH.innerHTML = headers[column];\n      }]\n    });\n    wt.draw();\n\n    const visibleHeaders = headers.slice(0, wt.wtTable.getLastRenderedColumn() + 1); // headers for rendered columns only\n\n    expect($table.find('thead tr:first th').length).toBe(visibleHeaders.length);\n    expect($table.find('thead tr:first th').text()).toEqual(visibleHeaders.join(''));\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/settings/columnHeaders.spec.js","describe('preventOverflow option', () => {\n  let $table;\n  let $container;\n  let $wrapper;\n  const debug = false;\n\n  beforeEach(() => {\n    $wrapper = $('<div></div>').css({ position: 'relative' });\n    $wrapper.width(500).height(201);\n    $container = $('<div></div>');\n    $table = $('<table></table>'); // create a table that is not attached to document\n    $wrapper.append($container);\n    $container.append($table);\n    $wrapper.appendTo('body');\n    createDataArray(100, 100);\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n    $wrapper.remove();\n  });\n\n  it('should set overflow to `auto` for master table when `horizontal` value is passed', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      preventOverflow() {\n        return 'horizontal';\n      }\n    });\n    wt.draw();\n\n    expect($table.parents('.wtHolder').css('overflow')).toBe('auto');\n    expect($table.parents('.ht_master').css('overflow')).toBe('visible');\n  });\n\n  it('should set overflow-x to `auto` for top clone when `horizontal` value is passed', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(column, TH) {\n        TH.innerHTML = column + 1;\n      }],\n      preventOverflow() {\n        return 'horizontal';\n      }\n    });\n    wt.draw();\n\n    expect($(wt.wtTable.wtRootElement.parentNode).find('.ht_clone_top .wtHolder').css('overflow-x')).toBe('auto');\n    expect($(wt.wtTable.wtRootElement.parentNode).find('.ht_clone_top .wtHolder').css('overflow-y')).toBe('hidden');\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/settings/preventOverflow.spec.js","describe('rowHeaders option', () => {\n  let $table;\n  let $container;\n  let $wrapper;\n  const debug = false;\n\n  beforeEach(() => {\n    $wrapper = $('<div></div>').css({ overflow: 'hidden', position: 'relative' });\n    $wrapper.width(500).height(201);\n    $container = $('<div></div>');\n    $table = $('<table></table>'); // create a table that is not attached to document\n    $wrapper.append($container);\n    $container.append($table);\n    $wrapper.appendTo('body');\n    createDataArray();\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n    $wrapper.remove();\n  });\n\n  it('should not add class `htRowHeader` when row headers are disabled', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    expect($wrapper.hasClass('htRowHeaders')).toBe(false);\n  });\n\n  it('should add class `htRowHeader` when row headers are enabled', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }]\n    });\n    wt.draw();\n\n    expect($wrapper.hasClass('htRowHeaders')).toBe(true);\n  });\n\n  it('should create table row headers', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }]\n    });\n    wt.draw();\n\n    expect($wrapper.find('.ht_clone_left colgroup col').length).toBe(1);\n    expect($wrapper.find('.ht_clone_left thead tr').length).toBe(0);\n    expect($wrapper.find('.ht_clone_left tbody tr').length).toBe(9);\n    expect($wrapper.find('.ht_clone_top colgroup col').length).toBe(0);\n    expect($wrapper.find('.ht_clone_top thead tr').length).toBe(0);\n    expect($wrapper.find('.ht_clone_top tbody tr').length).toBe(0);\n    expect($wrapper.find('.ht_master colgroup col').length).toBe(5);\n    expect($wrapper.find('.ht_master thead tr').length).toBe(0);\n    expect($wrapper.find('.ht_master tbody tr').length).toBe(9);\n  });\n\n  it('should generate headers from function', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }]\n    });\n\n    wt.draw();\n    const potentialRowCount = 9;\n    expect($table.find('tbody td').length).toBe(potentialRowCount * wt.wtTable.getRenderedColumnsCount()); // displayed cells\n    expect($table.find('tbody th').length).toBe(potentialRowCount); // 9*1=9 displayed row headers\n    expect($table.find('tbody tr:first th').length).toBe(1); // only one th per row\n    expect($table.find('tbody tr:first th')[0].innerHTML).toBe('1'); // this should be the first row header\n  });\n\n  it('should add \\'rowHeader\\' class to row header column', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }],\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }]\n    });\n    wt.draw();\n\n    expect($table.find('col:first').hasClass('rowHeader')).toBe(true);\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/settings/rowHeaders.spec.js","describe('stretchH option', () => {\n  let $table;\n  let $container;\n  let $wrapper;\n  const debug = false;\n\n  beforeEach(() => {\n    $wrapper = $('<div></div>').css({ overflow: 'hidden', position: 'relative' });\n    $wrapper.width(500).height(201);\n    $container = $('<div></div>');\n    $table = $('<table></table>'); // create a table that is not attached to document\n    $wrapper.append($container);\n    $container.append($table);\n    $wrapper.appendTo('body');\n    createDataArray();\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n    $wrapper.remove();\n  });\n\n  it('should stretch all visible columns when stretchH equals \\'all\\'', () => {\n    createDataArray(20, 2);\n\n    $wrapper.width(500).height(400);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      stretchH: 'all',\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }]\n    });\n    wt.draw();\n\n    expect($table.outerWidth()).toBeAroundValue(wt.wtTable.holder.clientWidth);\n    // fix differences between Mac and Linux PhantomJS\n    expect($table.find('col:eq(2)').width() - $table.find('col:eq(1)').width()).toBeInArray([-1, 0, 1]);\n  });\n\n  it('should stretch all visible columns when stretchH equals \\'all\\' and window is resized', (done) => {\n    createDataArray(20, 2);\n\n    $wrapper.width(500).height(400);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      stretchH: 'all',\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }]\n    });\n    wt.draw();\n\n    const initialTableWidth = $table.outerWidth();\n    expect(initialTableWidth).toBeAroundValue($table[0].clientWidth);\n\n    $wrapper.width(600).height(500);\n\n    const evt = document.createEvent('CustomEvent'); // MUST be 'CustomEvent'\n    evt.initCustomEvent('resize', false, false, null);\n    window.dispatchEvent(evt);\n\n    setTimeout(() => {\n      const currentTableWidth = $table.outerWidth();\n      expect(currentTableWidth).toBeAroundValue($table[0].clientWidth);\n      expect(currentTableWidth).toBeGreaterThan(initialTableWidth);\n      done();\n    }, 10);\n  });\n\n  it('should stretch all visible columns when stretchH equals \\'all\\' (when rows are of variable height)', function() {\n    createDataArray(20, 2);\n\n    for (let i = 0, ilen = this.data.length; i < ilen; i++) {\n      if (i % 2) {\n        this.data[i][0] += ' this is a cell that contains a lot of text, which will make it multi-line';\n      }\n    }\n\n    $wrapper.width(300);\n    $wrapper.css({\n      overflow: 'hidden'\n    });\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      stretchH: 'all'\n    });\n    wt.draw();\n\n    let expectedColWidth = ((300 - getScrollbarWidth()) / 2);\n    expectedColWidth = Math.floor(expectedColWidth);\n\n    const wtHider = $table.parents('.wtHider');\n    expect(wtHider.find('col:eq(0)').width()).toBeAroundValue(expectedColWidth);\n    expect(wtHider.find('col:eq(1)').width() - expectedColWidth).toBeInArray([0, 1]); // fix differences between Mac and Linux PhantomJS\n  });\n\n  it('should stretch last visible column when stretchH equals \\'last\\' (vertical scroll)', () => {\n    createDataArray(20, 2);\n\n    $wrapper.width(300).height(201);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      stretchH: 'last',\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }]\n    });\n    wt.draw();\n\n    const wtHider = $table.parents('.wtHider');\n    expect(wtHider.outerWidth()).toBe(getTableWidth($table));\n    expect(wtHider.find('col:eq(1)').width()).toBeLessThan(wtHider.find('col:eq(2)').width());\n  });\n\n  it('should stretch last column when stretchH equals \\'last\\' (horizontal scroll)', () => {\n    createDataArray(5, 20);\n\n    $wrapper.width(400).height(201);\n    spec().data[0][19] = 'longer text';\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      stretchH: 'last',\n      columnHeaders: [function(index, TH) {\n        TH.innerHTML = index + 1;\n      }],\n      columnWidth(index) {\n        return index === 19 ? 100 : 50;\n      }\n    });\n\n    wt.draw();\n    wt.scrollViewportHorizontally(19);\n    wt.draw();\n\n    const wtHider = $table.parents('.wtHider');\n\n    expect(wtHider.find('col:eq(6)').width()).toBe(100);\n  });\n\n  it('should stretch last visible column when stretchH equals \\'last\\' (no scrolls)', () => {\n    createDataArray(2, 2);\n\n    $wrapper.width(300).height(201);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      stretchH: 'last',\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }]\n    });\n    wt.draw();\n\n    const wtHider = $table.parents('.wtHider');\n    expect(wtHider.outerWidth()).toBe(getTableWidth($table));\n    expect(wtHider.find('col:eq(1)').width()).toBeLessThan(wtHider.find('col:eq(2)').width());\n  });\n\n  it('should not stretch when stretchH equals \\'none\\'', () => {\n    createDataArray(20, 2);\n    $wrapper.width(300).height(201);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      stretchH: 'none',\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }]\n    });\n    wt.draw();\n\n    expect($table.width()).toBeLessThan($wrapper.width());\n    expect($table.find('col:eq(1)').width()).toBe($table.find('col:eq(2)').width());\n  });\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/settings/stretchH.spec.js","describe('WalkontableTable', () => {\n  let $table;\n  let $container;\n  let $wrapper;\n  const debug = false;\n\n  beforeEach(() => {\n    $wrapper = $('<div></div>').css({ overflow: 'hidden', position: 'relative' });\n    $wrapper.width(100).height(201);\n    $container = $('<div></div>');\n    $table = $('<table></table>'); // create a table that is not attached to document\n    $wrapper.append($container);\n    $container.append($table);\n    $wrapper.appendTo('body');\n    createDataArray();\n  });\n\n  afterEach(() => {\n    if (!debug) {\n      $('.wtHolder').remove();\n    }\n\n    $wrapper.remove();\n  });\n\n  it('should create as many rows as fits in height', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n    expect($table.find('tbody tr').length).toBe(9);\n  });\n\n  it('should create as many rows as in `totalRows` if it is smaller than `height`', function() {\n    this.data.splice(5, this.data.length - 5);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n    expect($table.find('tbody tr').length).toBe(5);\n  });\n\n  it('first row should have as many columns as in THEAD', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }]\n    });\n    wt.draw();\n    expect($table.find('tbody tr:first td').length).toBe($table.find('thead th').length);\n  });\n\n  it('should put a blank cell in the corner if both rowHeaders and colHeaders are set', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [\n        function(col, TH) {\n          if (col > -1) {\n            TH.innerHTML = 'Column';\n          }\n        }\n      ],\n      rowHeaders: [\n        function(row, TH) {\n          if (row > -1) {\n            TH.innerHTML = 'Row';\n          }\n        }\n      ]\n    });\n    wt.draw();\n    expect($table.find('thead tr:first th').length).toBe(wt.wtTable.getRenderedColumnsCount() + 1); // 4 columns in THEAD + 1 empty cell in the corner\n    expect($table.find('thead tr:first th:eq(0)')[0].innerHTML.replace(/&nbsp;/, '')).toBe(''); // corner row is empty (or contains only &nbsp;)\n    expect($table.find('thead tr:first th:eq(1)')[0].innerHTML).toBe('Column');\n    expect($table.find('tbody tr:first th:eq(0)')[0].innerHTML).toBe('Row');\n  });\n\n  it('getCell should only return cells from rendered rows', function() {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    expect(wt.wtTable.getCell(new Walkontable.CellCoords(7, 0)) instanceof HTMLElement).toBe(true);\n    expect($table.find('tr:eq(8) td:first-child').text()).toEqual(this.data[8][0].toString());\n    expect(wt.wtTable.getCell(new Walkontable.CellCoords(20, 0))).toBe(-2); // exit code\n    expect(wt.wtTable.getCell(new Walkontable.CellCoords(25, 0))).toBe(-2); // exit code\n  });\n\n  it('getCoords should return coords of TD', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n\n    const $td2 = $table.find('tbody tr:eq(1) td:eq(1)');\n    expect(wt.wtTable.getCoords($td2[0])).toEqual(new Walkontable.CellCoords(1, 1));\n  });\n\n  it('getCoords should return coords of TD (with row header)', () => {\n\n    $wrapper.width(300);\n\n    function plusOne(i) {\n      return i + 1;\n    }\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = plusOne(row);\n      }]\n    });\n    wt.draw();\n\n    const $td2 = $table.find('tbody tr:eq(1) td:eq(1)');\n    expect(wt.wtTable.getCoords($td2[0])).toEqual(new Walkontable.CellCoords(1, 1));\n  });\n\n  it('getStretchedColumnWidth should return valid column width when stretchH is set as \\'all\\'', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }],\n      stretchH: 'all'\n    });\n    wt.draw();\n    wt.wtViewport.columnsRenderCalculator.refreshStretching(502);\n\n    expect(wt.wtTable.getStretchedColumnWidth(0, 50)).toBe(125);\n    expect(wt.wtTable.getStretchedColumnWidth(1, 50)).toBe(125);\n    expect(wt.wtTable.getStretchedColumnWidth(2, 50)).toBe(125);\n    expect(wt.wtTable.getStretchedColumnWidth(3, 50)).toBe(127);\n  });\n\n  it('getStretchedColumnWidth should return valid column width when stretchH is set as \\'last\\'', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }],\n      stretchH: 'last'\n    });\n    wt.draw();\n    wt.wtViewport.columnsRenderCalculator.refreshStretching(502);\n\n    expect(wt.wtTable.getStretchedColumnWidth(0, 50)).toBe(50);\n    expect(wt.wtTable.getStretchedColumnWidth(1, 50)).toBe(50);\n    expect(wt.wtTable.getStretchedColumnWidth(2, 50)).toBe(50);\n    expect(wt.wtTable.getStretchedColumnWidth(3, 50)).toBe(352);\n  });\n\n  it('should use custom cell renderer if provided', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      cellRenderer(row, column, TD) {\n        const cellData = getData(row, column);\n\n        if (cellData === void 0) {\n          TD.innerHTML = '';\n        } else {\n          TD.innerHTML = cellData;\n        }\n        TD.className = '';\n        TD.style.backgroundColor = 'yellow';\n      }\n    });\n    wt.draw();\n    expect($table.find('td:first')[0].style.backgroundColor).toBe('yellow');\n  });\n\n  it('should remove rows if they were removed in data source', function() {\n    this.data.splice(8, this.data.length - 8); // second param is required by IE8\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n    expect($table.find('tbody tr').length).toBe(8);\n\n    this.data.splice(7, this.data.length - 7); // second param is required by IE8\n    wt.draw();\n    expect($table.find('tbody tr').length).toBe(7);\n  });\n\n  it('should render as much columns as the container width allows, if width is null', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }]\n    });\n    wt.draw();\n    expect($table.find('thead tr:first').children().length).toBe(2);\n    expect($table.find('tbody tr:first').children().length).toBe(2);\n\n    $wrapper.width(200);\n    wt.draw();\n    expect($table.find('thead tr:first').children().length).toBe(4);\n    expect($table.find('tbody tr:first').children().length).toBe(4);\n  });\n\n  it('should render as much columns as the container width allows, if width is null (with row header)', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }],\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }]\n    });\n    wt.draw();\n    expect($table.find('thead tr:first').children().length).toBe(2);\n    expect($table.find('tbody tr:first').children().length).toBe(2);\n\n    $wrapper.width(200);\n    wt.draw();\n    expect($table.find('thead tr:first').children().length).toBe(4);\n    expect($table.find('tbody tr:first').children().length).toBe(4);\n  });\n\n  it('should use column width function to get column width', () => {\n\n    $wrapper.width(600);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }],\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }],\n      columnWidth(column) {\n        return (column + 1) * 50;\n      }\n    });\n    wt.draw();\n    expect($table.find('tbody tr:first td:eq(0)').outerWidth()).toBe(50);\n    expect($table.find('tbody tr:first td:eq(1)').outerWidth()).toBe(100);\n    expect($table.find('tbody tr:first td:eq(2)').outerWidth()).toBe(150);\n    expect($table.find('tbody tr:first td:eq(3)').outerWidth()).toBe(200);\n  });\n\n  it('should use column width array to get column width', () => {\n\n    $wrapper.width(600);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }],\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }],\n      columnWidth: [50, 100, 150, 201]\n    });\n    wt.draw();\n    expect($table.find('tbody tr:first td:eq(0)').outerWidth()).toBe(50);\n    expect($table.find('tbody tr:first td:eq(1)').outerWidth()).toBe(100);\n    expect($table.find('tbody tr:first td:eq(2)').outerWidth()).toBe(150);\n    expect($table.find('tbody tr:first td:eq(3)').outerWidth()).toBe(201);\n  });\n\n  it('should use column width integer to get column width', () => {\n\n    $wrapper.width(600);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }],\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }],\n      columnWidth: 100\n    });\n    wt.draw();\n    expect($table.find('tbody tr:first td:eq(0)').outerWidth()).toBe(100);\n    expect($table.find('tbody tr:first td:eq(1)').outerWidth()).toBe(100);\n    expect($table.find('tbody tr:first td:eq(2)').outerWidth()).toBe(100);\n    expect($table.find('tbody tr:first td:eq(3)').outerWidth()).toBe(100);\n  });\n\n  it('should use column width also when there are no rows', function() {\n    this.data.length = 0;\n\n    $wrapper.width(600);\n\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: 4,\n      rowHeaders: [function(row, TH) {\n        TH.innerHTML = row + 1;\n      }],\n      columnHeaders: [function(col, TH) {\n        TH.innerHTML = col + 1;\n      }],\n      columnWidth: 100\n    });\n    wt.draw();\n    // start from eq(1) because eq(0) is corner header\n    expect($table.find('thead tr:first th:eq(1)').outerWidth()).toBe(100);\n    expect($table.find('thead tr:first th:eq(2)').outerWidth()).toBe(100);\n    expect($table.find('thead tr:first th:eq(3)').outerWidth()).toBe(100);\n    expect($table.find('thead tr:first th:eq(4)').outerWidth()).toBe(100);\n  });\n\n  it('should render a cell that is outside of the viewport horizontally', () => {\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns\n    });\n    wt.draw();\n    $table.find('tbody td').html('');\n    wt.draw();\n    expect($table.find('tbody tr:first td').length).toBe(2);\n  });\n\n  it('should not render a cell when fastDraw == true', () => {\n    let count = 0;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      cellRenderer(row, column, TD) {\n        count += 1;\n        return wt.wtSettings.defaults.cellRenderer(row, column, TD);\n      }\n    });\n    wt.draw();\n    const oldCount = count;\n    wt.draw(true);\n    expect(count).toBe(oldCount);\n  });\n\n  it('should not ignore fastDraw == true when grid was scrolled by amount of rows that doesn\\'t exceed endRow', () => {\n    let count = 0;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      cellRenderer(row, column, TD) {\n        count += 1;\n        return wt.wtSettings.defaults.cellRenderer(row, column, TD);\n      },\n      viewportRowCalculatorOverride(calc) {\n        calc.endRow += 10;\n      }\n    });\n    wt.draw();\n    const oldCount = count;\n\n    wt.scrollViewportVertically(8);\n    wt.draw(true);\n    expect(count).not.toBeGreaterThan(oldCount);\n  });\n\n  it('should ignore fastDraw == true when grid was scrolled by amount of rows that exceeds endRow', () => {\n    let count = 0;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      cellRenderer(row, column, TD) {\n        count += 1;\n        return wt.wtSettings.defaults.cellRenderer(row, column, TD);\n      },\n      viewportRowCalculatorOverride(calc) {\n        calc.endRow += 10;\n      }\n    });\n    wt.draw();\n    const oldCount = count;\n\n    wt.scrollViewportVertically(10);\n    wt.draw(true);\n    expect(count).not.toBeGreaterThan(oldCount);\n\n    wt.scrollViewportVertically(getTotalRows() - 1);\n    wt.draw(true);\n    expect(count).toBeGreaterThan(oldCount);\n  });\n\n  it('should not ignore fastDraw == true when grid was scrolled by amount of columns that doesn\\'t exceed endColumn', () => {\n    createDataArray(50, 50);\n    let count = 0;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      cellRenderer(row, column, TD) {\n        count += 1;\n        return wt.wtSettings.defaults.cellRenderer(row, column, TD);\n      },\n      viewportColumnCalculatorOverride(calc) {\n        calc.endColumn += 10;\n      }\n    });\n    wt.draw();\n    const oldCount = count;\n\n    wt.scrollViewportHorizontally(8);\n    wt.draw(true);\n\n    expect(count).not.toBeGreaterThan(oldCount);\n  });\n\n  it('should ignore fastDraw == true when grid was scrolled by amount of columns that exceeds endColumn', () => {\n    createDataArray(50, 50);\n    let count = 0;\n    const wt = new Walkontable.Core({\n      table: $table[0],\n      data: getData,\n      totalRows: getTotalRows,\n      totalColumns: getTotalColumns,\n      cellRenderer(row, column, TD) {\n        count += 1;\n\n        return wt.wtSettings.defaults.cellRenderer(row, column, TD);\n      },\n      viewportColumnCalculatorOverride(calc) {\n        calc.endColumn += 10;\n      }\n    });\n    wt.draw();\n    const oldCount = count;\n\n    wt.scrollViewportHorizontally(10);\n    wt.draw(true);\n    expect(count).not.toBeGreaterThan(oldCount);\n\n    wt.scrollViewportHorizontally(11);\n    wt.draw(true);\n    expect(count).toBeGreaterThan(oldCount);\n  });\n\n  describe('cell header border', () => {\n    it('should be correct visible in fixedColumns and without row header', () => {\n      createDataArray(50, 50);\n      $wrapper.width(500).height(400);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns,\n        columnWidth: 70,\n        fixedColumnsLeft: 2,\n        columnHeaders: [function() {}]\n      });\n      wt.draw();\n\n      expect($('.ht_clone_top_left_corner thead tr th').eq(0).css('border-left-width')).toBe('1px');\n      expect($('.ht_clone_top_left_corner thead tr th').eq(0).css('border-right-width')).toBe('1px');\n      expect($('.ht_clone_top_left_corner thead tr th').eq(1).css('border-left-width')).toBe('0px');\n      expect($('.ht_clone_top_left_corner thead tr th').eq(1).css('border-right-width')).toBe('1px');\n    });\n  });\n\n  describe('isLastRowFullyVisible', () => {\n    it('should be false because it is only partially visible', () => {\n      createDataArray(8, 4);\n\n      $wrapper.width(185).height(175);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n      wt.draw();\n\n      expect(wt.wtTable.isLastRowFullyVisible()).toEqual(false);\n    });\n\n    it('should be true because it is fully visible', () => {\n      createDataArray(8, 4);\n\n      $wrapper.width(185).height(185);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n      wt.draw();\n      wt.scrollViewportVertically(7);\n      wt.draw();\n\n      expect(wt.wtTable.isLastRowFullyVisible()).toEqual(true);\n    });\n  });\n\n  xdescribe('isLastColumnFullyVisible', () => {\n    it('should be false because it is only partially visible', () => {\n      createDataArray(18, 4);\n\n      $wrapper.width(209).height(185);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n      wt.draw();\n\n      expect(wt.wtTable.isLastColumnFullyVisible()).toEqual(false); // few pixels are obstacled by scrollbar\n    });\n\n    it('should be true because it is fully visible', () => {\n      createDataArray(18, 4);\n\n      $wrapper.width(180).height(185);\n\n      const wt = new Walkontable.Core({\n        table: $table[0],\n        data: getData,\n        totalRows: getTotalRows,\n        totalColumns: getTotalColumns\n      });\n      wt.draw();\n      wt.scrollHorizontal(1);\n\n      expect(wt.wtTable.isLastColumnFullyVisible()).toEqual(true);\n    });\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/3rdparty/walkontable/test/spec/table.spec.js"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7DA;AAGA;AACA;AACA;AACA;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AADA;AAQA;AACA;AACA;AACA;AACA;AAjBA;AAmBA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AADA;AAQA;AACA;AACA;AACA;AACA;AAjBA;AAmBA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AADA;AAQA;AACA;AACA;AACA;AACA;AAjBA;AAmBA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AADA;AASA;AAVA;AAYA;AACA;AACA;AACA;AACA;AArBA;AAuBA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AAJA;AAPA;AAsBA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AADA;AASA;AAVA;AAYA;AACA;AACA;AACA;AACA;AArBA;AAuBA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AADA;AASA;AAVA;AAYA;AACA;AACA;AACA;AACA;AArBA;AAwBA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AADA;AASA;AAVA;AAYA;AACA;AACA;AACA;AACA;AArBA;AAwBA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AC1ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;ACpJA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;AAWA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;;;;;;;;;;AAUA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;;AAQA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;;;;AAUA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;;;;AAUA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;;AAQA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;;AAQA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;AC71CA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;ACpMA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAEA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAEA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AAEA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAaA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAaA;AAEA;AAIA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAaA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAaA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAaA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAEA;AACA;AADA;AAIA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AADA;AAUA;AACA;AACA;AACA;AAlBA;AAqBA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AADA;AAUA;AACA;AACA;AACA;AAlBA;AAqBA;AACA;AAEA;AAEA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AADA;AAUA;AACA;AACA;AAjBA;AAoBA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAFA;AADA;AALA;AAiBA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAEA;AACA;AACA;;;;;;;;;ACliBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5BA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAaA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AADA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AADA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAcA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAcA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAeA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;ACl7BA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AADA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AALA;AASA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAKA;AAEA;AACA;AACA;AAFA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AALA;AASA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AALA;AAYA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AADA;AAXA;AAkBA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;AC5VA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AAEA;AACA;AACA;AACA;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AAEA;AACA;AACA;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAcA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AAEA;AACA;AACA;AAEA;;;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAjBA;AAoBA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAfA;AAiBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAeA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAZA;AAcA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAEA;AACA;AACA;AACA;;;A","sourceRoot":""}